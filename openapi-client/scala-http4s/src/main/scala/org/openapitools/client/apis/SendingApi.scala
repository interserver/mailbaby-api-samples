/** MailBaby Email Delivery and Management Service API
  * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
  *
  * The version of the OpenAPI document: 1.3.0
  * Contact: support@interserver.net
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.apis

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.Uri
import org.http4s.client.Client as Http4sClient
import org.openapitools.client.models.EmailAddressTypes
import org.openapitools.client.models.EmailAddressesTypes
import org.openapitools.client.models.ErrorMessage
import org.openapitools.client.models.GenericResponse
import org.openapitools.client.models.MailAttachment
import org.openapitools.client.models.SendMailRaw
import org.openapitools.client.models.*

trait SendingApiEndpoints[F[*]] {

  def rawMail(sendMailRaw: SendMailRaw)(using auth: _Authorization.ApiKey): F[GenericResponse]
  def sendAdvMail(subject: String, body: String, from: EmailAddressTypes, to: EmailAddressesTypes, replyto: Option[EmailAddressesTypes] = None, cc: Option[EmailAddressesTypes] = None, bcc: Option[EmailAddressesTypes] = None, attachments: Option[Seq[MailAttachment]] = None, id: Option[Long] = None)(using auth: _Authorization.ApiKey): F[GenericResponse]
  def sendMail(to: String, from: String, subject: String, body: String, id: Option[Int] = None)(using auth: _Authorization.ApiKey): F[GenericResponse]

}

class SendingApiEndpointsImpl[F[*]: Concurrent](
  override val baseUrl: Uri,
  defaultHeaders: Seq[(String, String)] = Nil,
  httpClient: Http4sClient[F]
) extends BaseClient[F](baseUrl, defaultHeaders, httpClient) with SendingApiEndpoints[F] {
  
  import JsonSupports.*
  import io.circe.syntax.EncoderOps
  import cats.implicits.toFlatMapOps

  override def rawMail(sendMailRaw: SendMailRaw)(using auth: _Authorization.ApiKey): F[GenericResponse] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[SendMailRaw, GenericResponse](
      method = "POST",
      path = s"/mail/rawsend",
      body = Some(sendMailRaw),
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, GenericResponse]("GenericResponse", r)
        case r if r.status.code == 400 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def sendAdvMail(subject: String, body: String, from: EmailAddressTypes, to: EmailAddressesTypes, replyto: Option[EmailAddressesTypes] = None, cc: Option[EmailAddressesTypes] = None, bcc: Option[EmailAddressesTypes] = None, attachments: Option[Seq[MailAttachment]] = None, id: Option[Long] = None)(using auth: _Authorization.ApiKey): F[GenericResponse] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/x-www-form-urlencoded")
    ).flatten
    val formParameters = Some((
      Some(Seq("subject" -> subject)) ++ 
      Some(Seq("body" -> body)) ++ 
      Some(Seq("from" -> from)) ++ 
      Some(Seq("to" -> to)) ++ 
      replyto.map("replyto" -> _).map(Seq(_)) ++ 
      cc.map("cc" -> _).map(Seq(_)) ++ 
      bcc.map("bcc" -> _).map(Seq(_)) ++ 
      attachments.map(x => x.map("attachments" -> _)) ++ 
      id.map("id" -> _).map(Seq(_))
    ).toSeq.flatten)

    _executeRequest[Unit, GenericResponse](
      method = "POST",
      path = s"/mail/advsend",
      body = None,
      formParameters = formParameters,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, GenericResponse]("GenericResponse", r)
        case r if r.status.code == 400 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def sendMail(to: String, from: String, subject: String, body: String, id: Option[Int] = None)(using auth: _Authorization.ApiKey): F[GenericResponse] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/x-www-form-urlencoded")
    ).flatten
    val formParameters = Some((
      Some(Seq("to" -> to)) ++ 
      Some(Seq("from" -> from)) ++ 
      Some(Seq("subject" -> subject)) ++ 
      Some(Seq("body" -> body)) ++ 
      id.map("id" -> _).map(Seq(_))
    ).toSeq.flatten)

    _executeRequest[Unit, GenericResponse](
      method = "POST",
      path = s"/mail/send",
      body = None,
      formParameters = formParameters,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, GenericResponse]("GenericResponse", r)
        case r if r.status.code == 400 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

}


