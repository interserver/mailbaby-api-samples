/**
 * MailBaby Email Delivery and Management Service API
 * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: support@interserver.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Observable } from 'rxjs/Observable';

import { map } from 'rxjs/operators';
import IHttpClient from '../IHttpClient';
import { inject, injectable } from 'inversify';
import { IAPIConfiguration } from '../IAPIConfiguration';
import { Headers } from '../Headers';
import HttpResponse from '../HttpResponse';

import { ErrorMessage } from '../model/errorMessage';
import { MailLog } from '../model/mailLog';
import { MailStatsType } from '../model/mailStatsType';

import { COLLECTION_FORMATS }  from '../variables';



@injectable()
export class HistoryService {
    private basePath: string = 'https://api.mailbaby.net';

    constructor(@inject('IApiHttpClient') private httpClient: IHttpClient,
        @inject('IAPIConfiguration') private APIConfiguration: IAPIConfiguration ) {
        if(this.APIConfiguration.basePath)
            this.basePath = this.APIConfiguration.basePath;
    }

    /**
     * Account usage statistics.
     * Returns information about the usage on your mail accounts.
     * @param time The timeframe for the statistics.
     
     */
    public getStats(time?: 'all' | 'billing' | 'month' | '7d' | '24h' | '1d' | '1h', observe?: 'body', headers?: Headers): Observable<MailStatsType>;
    public getStats(time?: 'all' | 'billing' | 'month' | '7d' | '24h' | '1d' | '1h', observe?: 'response', headers?: Headers): Observable<HttpResponse<MailStatsType>>;
    public getStats(time?: 'all' | 'billing' | 'month' | '7d' | '24h' | '1d' | '1h', observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (time !== undefined) {
            queryParameters.push('time='+encodeURIComponent(String(time)));
        }

        // authentication (apiKeyAuth) required
        if (this.APIConfiguration.apiKeys && this.APIConfiguration.apiKeys['X-API-KEY']) {
            headers['X-API-KEY'] = this.APIConfiguration.apiKeys['X-API-KEY'];
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<MailStatsType>> = this.httpClient.get(`${this.basePath}/mail/stats?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <MailStatsType>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * displays the mail log
     * Get a listing of the emails sent through this system 
     * @param id The ID of your mail order this will be sent through.
     * @param origin originating ip address sending mail
     * @param mx mx record mail was sent to
     * @param from from email address
     * @param to to/destination email address
     * @param subject subject containing this string
     * @param mailid mail id
     * @param skip number of records to skip for pagination
     * @param limit maximum number of records to return
     * @param startDate earliest date to get emails in unix timestamp format
     * @param endDate earliest date to get emails in unix timestamp format
     * @param replyto Reply-To Email Address
     * @param headerfrom Header From Email Address
     * @param delivered Limiting the emails to wether or not they were delivered.
     
     */
    public viewMailLog(id?: number, origin?: string, mx?: string, from?: string, to?: string, subject?: string, mailid?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, replyto?: string, headerfrom?: string, delivered?: '0' | '1', observe?: 'body', headers?: Headers): Observable<MailLog>;
    public viewMailLog(id?: number, origin?: string, mx?: string, from?: string, to?: string, subject?: string, mailid?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, replyto?: string, headerfrom?: string, delivered?: '0' | '1', observe?: 'response', headers?: Headers): Observable<HttpResponse<MailLog>>;
    public viewMailLog(id?: number, origin?: string, mx?: string, from?: string, to?: string, subject?: string, mailid?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, replyto?: string, headerfrom?: string, delivered?: '0' | '1', observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (id !== undefined) {
            queryParameters.push('id='+encodeURIComponent(String(id)));
        }
        if (origin !== undefined) {
            queryParameters.push('origin='+encodeURIComponent(String(origin)));
        }
        if (mx !== undefined) {
            queryParameters.push('mx='+encodeURIComponent(String(mx)));
        }
        if (from !== undefined) {
            queryParameters.push('from='+encodeURIComponent(String(from)));
        }
        if (to !== undefined) {
            queryParameters.push('to='+encodeURIComponent(String(to)));
        }
        if (subject !== undefined) {
            queryParameters.push('subject='+encodeURIComponent(String(subject)));
        }
        if (mailid !== undefined) {
            queryParameters.push('mailid='+encodeURIComponent(String(mailid)));
        }
        if (skip !== undefined) {
            queryParameters.push('skip='+encodeURIComponent(String(skip)));
        }
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (startDate !== undefined) {
            queryParameters.push('startDate='+encodeURIComponent(String(startDate)));
        }
        if (endDate !== undefined) {
            queryParameters.push('endDate='+encodeURIComponent(String(endDate)));
        }
        if (replyto !== undefined) {
            queryParameters.push('replyto='+encodeURIComponent(String(replyto)));
        }
        if (headerfrom !== undefined) {
            queryParameters.push('headerfrom='+encodeURIComponent(String(headerfrom)));
        }
        if (delivered !== undefined) {
            queryParameters.push('delivered='+encodeURIComponent(String(delivered)));
        }

        // authentication (apiKeyAuth) required
        if (this.APIConfiguration.apiKeys && this.APIConfiguration.apiKeys['X-API-KEY']) {
            headers['X-API-KEY'] = this.APIConfiguration.apiKeys['X-API-KEY'];
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<MailLog>> = this.httpClient.get(`${this.basePath}/mail/log?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <MailLog>(httpResponse.response))
               );
        }
        return response;
    }

}
