extends ApiBee
class_name SendingApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API SendingApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "SendingApi"


# Operation sendAdvMail → POST /mail/advsend
# Sends an Email with Advanced Options
#
# Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.  Here are 9 examples showing the various ways to call the advsend operation showing the different ways you can pass the to, cc, bcc, and replyto information. The first several examples are all for the application/x-www-form-urlencoded content-type while the later ones are for application/json content-types.  ```BasicForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data to=support@interserver.net ```  ```ArrayForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to[0][name]=Joe\" \\ --data \"to[0][email]=support@interserver.net\" ```  ```NameEmailForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=\"Joe <user@domain.com>\" \\ --data to=\"Joe <support@interserver.net>\" ```  ```MultToForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to=support@interserver.net, support@interserver.net\" ```  ```MultToFullForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to=Joe <support@interserver.net>, Joe <support@interserver.net>\" ```  ```MultToArrayForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to[0][name]=Joe\" \\ --data \"to[0][email]=support@interserver.net\" \\ --data \"to[1][name]=Joe\" \\ --data \"to[1][email]=support@interserver.net\" ```  ```BasicJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": \"user@domain.com\", \"to\": \"support@interserver.net\" }' ```  ```ArrayJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": {\"name\": \"Joe\", \"email\": \"user@domain.com\"}, \"to\": [{\"name\": \"Joe\", \"email\": \"support@interserver.net\"}] }' ```  ```NameEmailJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": \"Joe <user@domain.com>\", \"to\": \"Joe <support@interserver.net>\" }' ``` 
func send_adv_mail(
	# subject: String = ""   Eg: subject_example
	# The subject or title of the email
	subject: String,
	# body: String = ""   Eg: body_example
	# The main email contents.
	body: String,
	# from: EmailAddressTypes
	from: EmailAddressTypes,
	# to: EmailAddressesTypes
	to: EmailAddressesTypes,
	# replyto: EmailAddressesTypes
	replyto = null,
	# cc: EmailAddressesTypes
	cc = null,
	# bcc: EmailAddressesTypes
	bcc = null,
	# attachments: Array
	# (optional) File attachments to include in the email.  The file contents must be base64 encoded!
	attachments = null,
	# id: float   Eg: 789
	# (optional)  ID of the Mail order within our system to use as the Mail Account.
	id = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/mail/advsend"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_consumable_by_server := ['application/x-www-form-urlencoded', 'application/json']
	var bzz_found_producible_mime := false
	for bzz_mime in BZZ_PRODUCIBLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_consumable_by_server:
			bzz_headers["Content-Type"] = bzz_mime
			bzz_found_producible_mime = true
			break
	if not bzz_found_producible_mime:
		var error := ApiError.new()
		error.identifier = "send_adv_mail.headers.content_type"
		error.message = "That endpoint only accepts %s as content type(s) and none are supported by this client."
		on_failure.call(error)
		return
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null
	bzz_body = Dictionary()
	bzz_body["subject"] = subject
	bzz_body["body"] = body
	bzz_body["from"] = from
	bzz_body["to"] = to
	bzz_body["replyto"] = replyto
	bzz_body["cc"] = cc
	bzz_body["bcc"] = bcc
	bzz_body["attachments"] = attachments
	bzz_body["id"] = id

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = GenericResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func send_adv_mail_threaded(
	# subject: String = ""   Eg: subject_example
	# The subject or title of the email
	subject: String,
	# body: String = ""   Eg: body_example
	# The main email contents.
	body: String,
	# from: EmailAddressTypes
	from: EmailAddressTypes,
	# to: EmailAddressesTypes
	to: EmailAddressesTypes,
	# replyto: EmailAddressesTypes
	replyto = null,
	# cc: EmailAddressesTypes
	cc = null,
	# bcc: EmailAddressesTypes
	bcc = null,
	# attachments: Array
	# (optional) File attachments to include in the email.  The file contents must be base64 encoded!
	attachments = null,
	# id: float   Eg: 789
	# (optional)  ID of the Mail order within our system to use as the Mail Account.
	id = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "send_adv_mail")
	bzz_callable.bind(
		subject,
		body,
		from,
		to,
		replyto,
		cc,
		bcc,
		attachments,
		id,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation sendMail → POST /mail/send
# Sends an Email
#
# Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
func send_mail(
	# to: String = ""   Eg: to_example
	# The Contact whom is the primary recipient of this email.
	to: String,
	# from: String = ""   Eg: from_example
	# The contact whom is the this email is from.
	from: String,
	# subject: String = ""   Eg: subject_example
	# The subject or title of the email
	subject: String,
	# body: String = ""   Eg: body_example
	# The main email contents.
	body: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/mail/send"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_consumable_by_server := ['application/x-www-form-urlencoded', 'application/json']
	var bzz_found_producible_mime := false
	for bzz_mime in BZZ_PRODUCIBLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_consumable_by_server:
			bzz_headers["Content-Type"] = bzz_mime
			bzz_found_producible_mime = true
			break
	if not bzz_found_producible_mime:
		var error := ApiError.new()
		error.identifier = "send_mail.headers.content_type"
		error.message = "That endpoint only accepts %s as content type(s) and none are supported by this client."
		on_failure.call(error)
		return
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null
	bzz_body = Dictionary()
	bzz_body["to"] = to
	bzz_body["from"] = from
	bzz_body["subject"] = subject
	bzz_body["body"] = body

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = GenericResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func send_mail_threaded(
	# to: String = ""   Eg: to_example
	# The Contact whom is the primary recipient of this email.
	to: String,
	# from: String = ""   Eg: from_example
	# The contact whom is the this email is from.
	from: String,
	# subject: String = ""   Eg: subject_example
	# The subject or title of the email
	subject: String,
	# body: String = ""   Eg: body_example
	# The main email contents.
	body: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "send_mail")
	bzz_callable.bind(
		to,
		from,
		subject,
		body,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


