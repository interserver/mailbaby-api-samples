/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MailBaby Email Delivery and Management Service API
 * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
 *
 * OpenAPI spec version: 1.3.0
 * Contact: support@interserver.net
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.mailbaby.net".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * The data for a email deny rule record.
 * @export
 * @interface DenyRuleNew
 */
export interface DenyRuleNew {
    /**
     * Mail account username that will be tied to this rule.  If not specified the first active mail order will be used.
     * @type {string}
     * @memberof DenyRuleNew
     */
    user?: string;
    /**
     * The type of deny rule.
     * @type {string}
     * @memberof DenyRuleNew
     */
    type: DenyRuleNew.TypeEnum;
    /**
     * The content of the rule.  If a domain type rule then an example would be google.com. For a begins with type an example would be msgid-.  For the email typer an example would be user@server.com.
     * @type {string}
     * @memberof DenyRuleNew
     */
    data: string;
}

/**
 * @export
 * @namespace DenyRuleNew
 */
export namespace DenyRuleNew {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Domain = <any> 'domain',
        Email = <any> 'email',
        Startswith = <any> 'startswith',
        Destination = <any> 'destination'
    }
}
/**
 * The data for a email deny rule record.
 * @export
 * @interface DenyRuleRecord
 */
export interface DenyRuleRecord {
    /**
     * The deny rule Id number.
     * @type {string}
     * @memberof DenyRuleRecord
     */
    id: string;
    /**
     * the date the rule was created.
     * @type {Date}
     * @memberof DenyRuleRecord
     */
    created: Date;
    /**
     * Mail account username that will be tied to this rule.  If not specified the first active mail order will be used.
     * @type {string}
     * @memberof DenyRuleRecord
     */
    user?: string;
    /**
     * The type of deny rule.
     * @type {string}
     * @memberof DenyRuleRecord
     */
    type: DenyRuleRecord.TypeEnum;
    /**
     * The content of the rule.  If a domain type rule then an example would be google.com. For a begins with type an example would be msgid-.  For the email typer an example would be user@server.com.
     * @type {string}
     * @memberof DenyRuleRecord
     */
    data: string;
}

/**
 * @export
 * @namespace DenyRuleRecord
 */
export namespace DenyRuleRecord {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Domain = <any> 'domain',
        Email = <any> 'email',
        Startswith = <any> 'startswith',
        Destination = <any> 'destination'
    }
}
/**
 * an email address
 * @export
 */
export type EmailAddress = string
/**
 * An email contact.
 * @export
 * @interface EmailAddressName
 */
export interface EmailAddressName {
    /**
     * The email address.
     * @type {string}
     * @memberof EmailAddressName
     */
    email: string;
    /**
     * Name to use for the sending contact.
     * @type {string}
     * @memberof EmailAddressName
     */
    name?: string;
}
/**
 * Array of Email Addresses
 * @export
 */
export type EmailAddressNames = Array<EmailAddressName>
/**
 * 
 * @export
 * @interface EmailAddressTypes
 */
export interface EmailAddressTypes {
}
/**
 * 
 * @export
 * @interface EmailAddressesTypes
 */
export interface EmailAddressesTypes {
}
/**
 * The resposne when an error occurs.
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
    /**
     * The response code associated with the error.
     * @type {number}
     * @memberof ErrorMessage
     */
    code: number;
    /**
     * The details or description of the error.
     * @type {string}
     * @memberof ErrorMessage
     */
    message: string;
}
/**
 * 
 * @export
 * @interface GenericResponse
 */
export interface GenericResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    text?: string;
}
/**
 * (optional) File attachments to include in the email.  The file contents must be base64
 * @export
 * @interface MailAttachment
 */
export interface MailAttachment {
    /**
     * The filename of the attached file.
     * @type {string}
     * @memberof MailAttachment
     */
    filename: string;
    /**
     * The file contents base64 encoded
     * @type {string}
     * @memberof MailAttachment
     */
    data: string;
}
/**
 * A block entry from the clickhouse mailblocks server.
 * @export
 * @interface MailBlockClickHouse
 */
export interface MailBlockClickHouse {
    /**
     * 
     * @type {string}
     * @memberof MailBlockClickHouse
     */
    date: string;
    /**
     * 
     * @type {string}
     * @memberof MailBlockClickHouse
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof MailBlockClickHouse
     */
    messageId: string;
    /**
     * 
     * @type {string}
     * @memberof MailBlockClickHouse
     */
    subject: string;
    /**
     * 
     * @type {string}
     * @memberof MailBlockClickHouse
     */
    to: string;
}
/**
 * This is a block entry from the rspamd block list.
 * @export
 * @interface MailBlockRspamd
 */
export interface MailBlockRspamd {
    /**
     * 
     * @type {string}
     * @memberof MailBlockRspamd
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof MailBlockRspamd
     */
    subject: string;
}
/**
 * The listing of blocked emails.
 * @export
 * @interface MailBlocks
 */
export interface MailBlocks {
    /**
     * 
     * @type {Array<MailBlockClickHouse>}
     * @memberof MailBlocks
     */
    local: Array<MailBlockClickHouse>;
    /**
     * 
     * @type {Array<MailBlockClickHouse>}
     * @memberof MailBlocks
     */
    mbtrap: Array<MailBlockClickHouse>;
    /**
     * 
     * @type {Array<MailBlockRspamd>}
     * @memberof MailBlocks
     */
    subject: Array<MailBlockRspamd>;
}
/**
 * Mail log records
 * @export
 * @interface MailLog
 */
export interface MailLog {
    /**
     * total number of mail log entries
     * @type {number}
     * @memberof MailLog
     */
    total: number;
    /**
     * number of emails skipped in listing
     * @type {number}
     * @memberof MailLog
     */
    skip: number;
    /**
     * number of emails to return
     * @type {number}
     * @memberof MailLog
     */
    limit: number;
    /**
     * 
     * @type {Array<MailLogEntry>}
     * @memberof MailLog
     */
    emails: Array<MailLogEntry>;
}
/**
 * An email record
 * @export
 * @interface MailLogEntry
 */
export interface MailLogEntry {
    /**
     * internal db id
     * @type {number}
     * @memberof MailLogEntry
     */
    id: number;
    /**
     * mail id
     * @type {string}
     * @memberof MailLogEntry
     */
    id: string;
    /**
     * from address
     * @type {string}
     * @memberof MailLogEntry
     */
    from: string;
    /**
     * to address
     * @type {string}
     * @memberof MailLogEntry
     */
    to: string;
    /**
     * email subject
     * @type {string}
     * @memberof MailLogEntry
     */
    subject: string;
    /**
     * message id
     * @type {string}
     * @memberof MailLogEntry
     */
    messageId?: string;
    /**
     * creation date
     * @type {string}
     * @memberof MailLogEntry
     */
    created: string;
    /**
     * creation timestamp
     * @type {number}
     * @memberof MailLogEntry
     */
    time: number;
    /**
     * user account
     * @type {string}
     * @memberof MailLogEntry
     */
    user: string;
    /**
     * transaction type
     * @type {string}
     * @memberof MailLogEntry
     */
    transtype: string;
    /**
     * origin ip
     * @type {string}
     * @memberof MailLogEntry
     */
    origin: string;
    /**
     * interface name
     * @type {string}
     * @memberof MailLogEntry
     */
    _interface: string;
    /**
     * sending zone
     * @type {string}
     * @memberof MailLogEntry
     */
    sendingZone: string;
    /**
     * email body size in bytes
     * @type {number}
     * @memberof MailLogEntry
     */
    bodySize: number;
    /**
     * index of email in the to adderess list
     * @type {number}
     * @memberof MailLogEntry
     */
    seq: number;
    /**
     * to address this email is being sent to
     * @type {string}
     * @memberof MailLogEntry
     */
    recipient: string;
    /**
     * to address domain
     * @type {string}
     * @memberof MailLogEntry
     */
    domain: string;
    /**
     * locked status
     * @type {number}
     * @memberof MailLogEntry
     */
    locked: number;
    /**
     * lock timestamp
     * @type {string}
     * @memberof MailLogEntry
     */
    lockTime: string;
    /**
     * assigned server
     * @type {string}
     * @memberof MailLogEntry
     */
    assigned: string;
    /**
     * queued timestamp
     * @type {string}
     * @memberof MailLogEntry
     */
    queued: string;
    /**
     * mx hostname
     * @type {string}
     * @memberof MailLogEntry
     */
    mxHostname: string;
    /**
     * mail delivery response
     * @type {string}
     * @memberof MailLogEntry
     */
    response: string;
}
/**
 * A mail order record
 * @export
 * @interface MailOrder
 */
export interface MailOrder {
    /**
     * The ID of the order.
     * @type {number}
     * @memberof MailOrder
     */
    id: number;
    /**
     * The order status.
     * @type {string}
     * @memberof MailOrder
     */
    status: string;
    /**
     * The username to use for this order.
     * @type {string}
     * @memberof MailOrder
     */
    username: string;
    /**
     * Optional order comment.
     * @type {string}
     * @memberof MailOrder
     */
    comment?: string;
}
/**
 * Statistics about the mail usage including volume by IP, To address, and From address; as well as total sent / delivered counts and cost.
 * @export
 * @interface MailStatsType
 */
export interface MailStatsType {
    /**
     * 
     * @type {string}
     * @memberof MailStatsType
     */
    time?: MailStatsType.TimeEnum;
    /**
     * 
     * @type {number}
     * @memberof MailStatsType
     */
    usage?: number;
    /**
     * 
     * @type {string}
     * @memberof MailStatsType
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof MailStatsType
     */
    currencySymbol?: string;
    /**
     * 
     * @type {number}
     * @memberof MailStatsType
     */
    cost?: number;
    /**
     * 
     * @type {number}
     * @memberof MailStatsType
     */
    received?: number;
    /**
     * 
     * @type {number}
     * @memberof MailStatsType
     */
    sent?: number;
    /**
     * 
     * @type {MailStatsTypeVolume}
     * @memberof MailStatsType
     */
    volume?: MailStatsTypeVolume;
}

/**
 * @export
 * @namespace MailStatsType
 */
export namespace MailStatsType {
    /**
     * @export
     * @enum {string}
     */
    export enum TimeEnum {
        All = <any> 'all',
        Billing = <any> 'billing',
        Month = <any> 'month',
        _7d = <any> '7d',
        _24h = <any> '24h',
        Today = <any> 'today',
        _1h = <any> '1h'
    }
}
/**
 * 
 * @export
 * @interface MailStatsTypeVolume
 */
export interface MailStatsTypeVolume {
    /**
     * 
     * @type {MailStatsTypeVolumeTo}
     * @memberof MailStatsTypeVolume
     */
    to?: MailStatsTypeVolumeTo;
    /**
     * 
     * @type {MailStatsTypeVolumeFrom}
     * @memberof MailStatsTypeVolume
     */
    from?: MailStatsTypeVolumeFrom;
    /**
     * 
     * @type {MailStatsTypeVolumeIp}
     * @memberof MailStatsTypeVolume
     */
    ip?: MailStatsTypeVolumeIp;
}
/**
 * 
 * @export
 * @interface MailStatsTypeVolumeFrom
 */
export interface MailStatsTypeVolumeFrom {
    /**
     * 
     * @type {number}
     * @memberof MailStatsTypeVolumeFrom
     */
    billingsomedomainCom?: number;
    /**
     * 
     * @type {number}
     * @memberof MailStatsTypeVolumeFrom
     */
    salessomedomainCom?: number;
}
/**
 * 
 * @export
 * @interface MailStatsTypeVolumeIp
 */
export interface MailStatsTypeVolumeIp {
    /**
     * 
     * @type {number}
     * @memberof MailStatsTypeVolumeIp
     */
    _1111?: number;
    /**
     * 
     * @type {number}
     * @memberof MailStatsTypeVolumeIp
     */
    _2222?: number;
    /**
     * 
     * @type {number}
     * @memberof MailStatsTypeVolumeIp
     */
    _3333?: number;
    /**
     * 
     * @type {number}
     * @memberof MailStatsTypeVolumeIp
     */
    _4444?: number;
}
/**
 * 
 * @export
 * @interface MailStatsTypeVolumeTo
 */
export interface MailStatsTypeVolumeTo {
    /**
     * 
     * @type {number}
     * @memberof MailStatsTypeVolumeTo
     */
    clientdomainCom?: number;
    /**
     * 
     * @type {number}
     * @memberof MailStatsTypeVolumeTo
     */
    usersiteNet?: number;
    /**
     * 
     * @type {number}
     * @memberof MailStatsTypeVolumeTo
     */
    salescompanyCom?: number;
    /**
     * 
     * @type {number}
     * @memberof MailStatsTypeVolumeTo
     */
    clientanothersiteCom?: number;
}
/**
 * Raw Email Object
 * @export
 * @interface RawMail
 */
export interface RawMail {
    /**
     * The entire email contents
     * @type {string}
     * @memberof RawMail
     */
    rawEmail: string;
}
/**
 * Details for an Email
 * @export
 * @interface SendMail
 */
export interface SendMail {
    /**
     * The Contact whom is the primary recipient of this email.
     * @type {string}
     * @memberof SendMail
     */
    to: string;
    /**
     * The contact whom is the this email is from.
     * @type {string}
     * @memberof SendMail
     */
    from: string;
    /**
     * The subject or title of the email
     * @type {string}
     * @memberof SendMail
     */
    subject: string;
    /**
     * The main email contents.
     * @type {string}
     * @memberof SendMail
     */
    body: string;
}
/**
 * Details for an Email
 * @export
 * @interface SendMailAdv
 */
export interface SendMailAdv {
    /**
     * The subject or title of the email
     * @type {string}
     * @memberof SendMailAdv
     */
    subject: string;
    /**
     * The main email contents.
     * @type {string}
     * @memberof SendMailAdv
     */
    body: string;
    /**
     * 
     * @type {EmailAddressTypes}
     * @memberof SendMailAdv
     */
    from: EmailAddressTypes;
    /**
     * 
     * @type {EmailAddressesTypes}
     * @memberof SendMailAdv
     */
    to: EmailAddressesTypes;
    /**
     * 
     * @type {EmailAddressesTypes}
     * @memberof SendMailAdv
     */
    replyto?: EmailAddressesTypes;
    /**
     * 
     * @type {EmailAddressesTypes}
     * @memberof SendMailAdv
     */
    cc?: EmailAddressesTypes;
    /**
     * 
     * @type {EmailAddressesTypes}
     * @memberof SendMailAdv
     */
    bcc?: EmailAddressesTypes;
    /**
     * (optional) File attachments to include in the email.  The file contents must be base64 encoded!
     * @type {Array<MailAttachment>}
     * @memberof SendMailAdv
     */
    attachments?: Array<MailAttachment>;
    /**
     * (optional)  ID of the Mail order within our system to use as the Mail Account.
     * @type {number}
     * @memberof SendMailAdv
     */
    id?: number;
}
/**
 * BlockingApi - fetch parameter creator
 * @export
 */
export const BlockingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new email deny rule into the system to block new emails that match the given criteria
         * @summary Creates a new email deny rule.
         * @param {string} user 
         * @param {string} type 
         * @param {string} data 
         * @param {DenyRuleNew} body These are the fields needed to create a new email deny rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRule(user: string, type: string, data: string, body: DenyRuleNew, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling addRule.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling addRule.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling addRule.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addRule.');
            }
            const localVarPath = `/mail/rules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (user !== undefined) {
                localVarFormParams.set('user', user as any);
            }

            if (type !== undefined) {
                localVarFormParams.set('type', type as any);
            }

            if (data !== undefined) {
                localVarFormParams.set('data', data as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"DenyRuleNew" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes one of the configured deny mail rules from the system.
         * @summary Removes an deny mail rule.
         * @param {number} ruleId The ID of the Rules entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(ruleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling deleteRule.');
            }
            const localVarPath = `/mail/rules/{ruleId}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an email address from the various block lists. 
         * @summary Removes an email address from the blocked list
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delistBlock(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling delistBlock.');
            }
            const localVarPath = `/mail/blocks/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary displays a list of blocked email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailBlocks(options: any = {}): FetchArgs {
            const localVarPath = `/mail/blocks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a listing of all the deny block rules you have configured.
         * @summary Displays a listing of deny email rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules(options: any = {}): FetchArgs {
            const localVarPath = `/mail/rules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockingApi - functional programming interface
 * @export
 */
export const BlockingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new email deny rule into the system to block new emails that match the given criteria
         * @summary Creates a new email deny rule.
         * @param {string} user 
         * @param {string} type 
         * @param {string} data 
         * @param {DenyRuleNew} body These are the fields needed to create a new email deny rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRule(user: string, type: string, data: string, body: DenyRuleNew, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericResponse> {
            const localVarFetchArgs = BlockingApiFetchParamCreator(configuration).addRule(user, type, data, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes one of the configured deny mail rules from the system.
         * @summary Removes an deny mail rule.
         * @param {number} ruleId The ID of the Rules entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(ruleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericResponse> {
            const localVarFetchArgs = BlockingApiFetchParamCreator(configuration).deleteRule(ruleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes an email address from the various block lists. 
         * @summary Removes an email address from the blocked list
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delistBlock(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericResponse> {
            const localVarFetchArgs = BlockingApiFetchParamCreator(configuration).delistBlock(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary displays a list of blocked email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailBlocks(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MailBlocks> {
            const localVarFetchArgs = BlockingApiFetchParamCreator(configuration).getMailBlocks(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a listing of all the deny block rules you have configured.
         * @summary Displays a listing of deny email rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DenyRuleRecord>> {
            const localVarFetchArgs = BlockingApiFetchParamCreator(configuration).getRules(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BlockingApi - factory interface
 * @export
 */
export const BlockingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new email deny rule into the system to block new emails that match the given criteria
         * @summary Creates a new email deny rule.
         * @param {string} user 
         * @param {string} type 
         * @param {string} data 
         * @param {DenyRuleNew} body These are the fields needed to create a new email deny rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRule(user: string, type: string, data: string, body: DenyRuleNew, options?: any) {
            return BlockingApiFp(configuration).addRule(user, type, data, body, options)(fetch, basePath);
        },
        /**
         * Removes one of the configured deny mail rules from the system.
         * @summary Removes an deny mail rule.
         * @param {number} ruleId The ID of the Rules entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(ruleId: number, options?: any) {
            return BlockingApiFp(configuration).deleteRule(ruleId, options)(fetch, basePath);
        },
        /**
         * Removes an email address from the various block lists. 
         * @summary Removes an email address from the blocked list
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delistBlock(body: string, options?: any) {
            return BlockingApiFp(configuration).delistBlock(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary displays a list of blocked email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailBlocks(options?: any) {
            return BlockingApiFp(configuration).getMailBlocks(options)(fetch, basePath);
        },
        /**
         * Returns a listing of all the deny block rules you have configured.
         * @summary Displays a listing of deny email rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules(options?: any) {
            return BlockingApiFp(configuration).getRules(options)(fetch, basePath);
        },
    };
};

/**
 * BlockingApi - object-oriented interface
 * @export
 * @class BlockingApi
 * @extends {BaseAPI}
 */
export class BlockingApi extends BaseAPI {
    /**
     * Adds a new email deny rule into the system to block new emails that match the given criteria
     * @summary Creates a new email deny rule.
     * @param {string} user 
     * @param {string} type 
     * @param {string} data 
     * @param {DenyRuleNew} body These are the fields needed to create a new email deny rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockingApi
     */
    public addRule(user: string, type: string, data: string, body: DenyRuleNew, options?: any) {
        return BlockingApiFp(this.configuration).addRule(user, type, data, body, options)(this.fetch, this.basePath);
    }

    /**
     * Removes one of the configured deny mail rules from the system.
     * @summary Removes an deny mail rule.
     * @param {number} ruleId The ID of the Rules entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockingApi
     */
    public deleteRule(ruleId: number, options?: any) {
        return BlockingApiFp(this.configuration).deleteRule(ruleId, options)(this.fetch, this.basePath);
    }

    /**
     * Removes an email address from the various block lists. 
     * @summary Removes an email address from the blocked list
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockingApi
     */
    public delistBlock(body: string, options?: any) {
        return BlockingApiFp(this.configuration).delistBlock(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary displays a list of blocked email addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockingApi
     */
    public getMailBlocks(options?: any) {
        return BlockingApiFp(this.configuration).getMailBlocks(options)(this.fetch, this.basePath);
    }

    /**
     * Returns a listing of all the deny block rules you have configured.
     * @summary Displays a listing of deny email rules.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockingApi
     */
    public getRules(options?: any) {
        return BlockingApiFp(this.configuration).getRules(options)(this.fetch, this.basePath);
    }

}
/**
 * HistoryApi - fetch parameter creator
 * @export
 */
export const HistoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information about the usage on your mail accounts.
         * @summary Account usage statistics.
         * @param {string} [time] The timeframe for the statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(time?: string, options: any = {}): FetchArgs {
            const localVarPath = `/mail/stats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a listing of the emails sent through this system 
         * @summary displays the mail log
         * @param {number} [id] The ID of your mail order this will be sent through.
         * @param {string} [origin] originating ip address sending mail
         * @param {string} [mx] mx record mail was sent to
         * @param {string} [from] from email address
         * @param {string} [to] to/destination email address
         * @param {string} [subject] subject containing this string
         * @param {string} [mailid] mail id
         * @param {number} [skip] number of records to skip for pagination
         * @param {number} [limit] maximum number of records to return
         * @param {number} [startDate] earliest date to get emails in unix timestamp format
         * @param {number} [endDate] earliest date to get emails in unix timestamp format
         * @param {string} [replyto] Reply-To Email Address
         * @param {string} [headerfrom] Header From Email Address
         * @param {string} [delivered] Limiting the emails to wether or not they were delivered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewMailLog(id?: number, origin?: string, mx?: string, from?: string, to?: string, subject?: string, mailid?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, replyto?: string, headerfrom?: string, delivered?: string, options: any = {}): FetchArgs {
            const localVarPath = `/mail/log`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }

            if (mx !== undefined) {
                localVarQueryParameter['mx'] = mx;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (subject !== undefined) {
                localVarQueryParameter['subject'] = subject;
            }

            if (mailid !== undefined) {
                localVarQueryParameter['mailid'] = mailid;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (replyto !== undefined) {
                localVarQueryParameter['replyto'] = replyto;
            }

            if (headerfrom !== undefined) {
                localVarQueryParameter['headerfrom'] = headerfrom;
            }

            if (delivered !== undefined) {
                localVarQueryParameter['delivered'] = delivered;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoryApi - functional programming interface
 * @export
 */
export const HistoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns information about the usage on your mail accounts.
         * @summary Account usage statistics.
         * @param {string} [time] The timeframe for the statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(time?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MailStatsType> {
            const localVarFetchArgs = HistoryApiFetchParamCreator(configuration).getStats(time, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a listing of the emails sent through this system 
         * @summary displays the mail log
         * @param {number} [id] The ID of your mail order this will be sent through.
         * @param {string} [origin] originating ip address sending mail
         * @param {string} [mx] mx record mail was sent to
         * @param {string} [from] from email address
         * @param {string} [to] to/destination email address
         * @param {string} [subject] subject containing this string
         * @param {string} [mailid] mail id
         * @param {number} [skip] number of records to skip for pagination
         * @param {number} [limit] maximum number of records to return
         * @param {number} [startDate] earliest date to get emails in unix timestamp format
         * @param {number} [endDate] earliest date to get emails in unix timestamp format
         * @param {string} [replyto] Reply-To Email Address
         * @param {string} [headerfrom] Header From Email Address
         * @param {string} [delivered] Limiting the emails to wether or not they were delivered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewMailLog(id?: number, origin?: string, mx?: string, from?: string, to?: string, subject?: string, mailid?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, replyto?: string, headerfrom?: string, delivered?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MailLog> {
            const localVarFetchArgs = HistoryApiFetchParamCreator(configuration).viewMailLog(id, origin, mx, from, to, subject, mailid, skip, limit, startDate, endDate, replyto, headerfrom, delivered, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HistoryApi - factory interface
 * @export
 */
export const HistoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns information about the usage on your mail accounts.
         * @summary Account usage statistics.
         * @param {string} [time] The timeframe for the statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(time?: string, options?: any) {
            return HistoryApiFp(configuration).getStats(time, options)(fetch, basePath);
        },
        /**
         * Get a listing of the emails sent through this system 
         * @summary displays the mail log
         * @param {number} [id] The ID of your mail order this will be sent through.
         * @param {string} [origin] originating ip address sending mail
         * @param {string} [mx] mx record mail was sent to
         * @param {string} [from] from email address
         * @param {string} [to] to/destination email address
         * @param {string} [subject] subject containing this string
         * @param {string} [mailid] mail id
         * @param {number} [skip] number of records to skip for pagination
         * @param {number} [limit] maximum number of records to return
         * @param {number} [startDate] earliest date to get emails in unix timestamp format
         * @param {number} [endDate] earliest date to get emails in unix timestamp format
         * @param {string} [replyto] Reply-To Email Address
         * @param {string} [headerfrom] Header From Email Address
         * @param {string} [delivered] Limiting the emails to wether or not they were delivered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewMailLog(id?: number, origin?: string, mx?: string, from?: string, to?: string, subject?: string, mailid?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, replyto?: string, headerfrom?: string, delivered?: string, options?: any) {
            return HistoryApiFp(configuration).viewMailLog(id, origin, mx, from, to, subject, mailid, skip, limit, startDate, endDate, replyto, headerfrom, delivered, options)(fetch, basePath);
        },
    };
};

/**
 * HistoryApi - object-oriented interface
 * @export
 * @class HistoryApi
 * @extends {BaseAPI}
 */
export class HistoryApi extends BaseAPI {
    /**
     * Returns information about the usage on your mail accounts.
     * @summary Account usage statistics.
     * @param {string} [time] The timeframe for the statistics.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getStats(time?: string, options?: any) {
        return HistoryApiFp(this.configuration).getStats(time, options)(this.fetch, this.basePath);
    }

    /**
     * Get a listing of the emails sent through this system 
     * @summary displays the mail log
     * @param {number} [id] The ID of your mail order this will be sent through.
     * @param {string} [origin] originating ip address sending mail
     * @param {string} [mx] mx record mail was sent to
     * @param {string} [from] from email address
     * @param {string} [to] to/destination email address
     * @param {string} [subject] subject containing this string
     * @param {string} [mailid] mail id
     * @param {number} [skip] number of records to skip for pagination
     * @param {number} [limit] maximum number of records to return
     * @param {number} [startDate] earliest date to get emails in unix timestamp format
     * @param {number} [endDate] earliest date to get emails in unix timestamp format
     * @param {string} [replyto] Reply-To Email Address
     * @param {string} [headerfrom] Header From Email Address
     * @param {string} [delivered] Limiting the emails to wether or not they were delivered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public viewMailLog(id?: number, origin?: string, mx?: string, from?: string, to?: string, subject?: string, mailid?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, replyto?: string, headerfrom?: string, delivered?: string, options?: any) {
        return HistoryApiFp(this.configuration).viewMailLog(id, origin, mx, from, to, subject, mailid, skip, limit, startDate, endDate, replyto, headerfrom, delivered, options)(this.fetch, this.basePath);
    }

}
/**
 * SendingApi - fetch parameter creator
 * @export
 */
export const SendingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This call will let you pass the raw / complete email contents (including headers) as a string and have it get sent as-is.  This is useful for things like DKIM signed messages.
         * @summary Sends a raw email
         * @param {RawMail} body 
         * @param {string} rawEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawMail(body: RawMail, rawEmail: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rawMail.');
            }
            // verify required parameter 'rawEmail' is not null or undefined
            if (rawEmail === null || rawEmail === undefined) {
                throw new RequiredError('rawEmail','Required parameter rawEmail was null or undefined when calling rawMail.');
            }
            const localVarPath = `/mail/rawsend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (rawEmail !== undefined) {
                localVarFormParams.set('raw_email', rawEmail as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"RawMail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.  Here are 9 examples showing the various ways to call the advsend operation showing the different ways you can pass the to, cc, bcc, and replyto information. The first several examples are all for the application/x-www-form-urlencoded content-type while the later ones are for application/json content-types.  ```BasicForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data to=support@interserver.net ```  ```ArrayForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to[0][name]=Joe\" \\ --data \"to[0][email]=support@interserver.net\" ```  ```NameEmailForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=\"Joe <user@domain.com>\" \\ --data to=\"Joe <support@interserver.net>\" ```  ```MultToForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to=support@interserver.net, support@interserver.net\" ```  ```MultToFullForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to=Joe <support@interserver.net>, Joe <support@interserver.net>\" ```  ```MultToArrayForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to[0][name]=Joe\" \\ --data \"to[0][email]=support@interserver.net\" \\ --data \"to[1][name]=Joe\" \\ --data \"to[1][email]=support@interserver.net\" ```  ```BasicJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": \"user@domain.com\", \"to\": \"support@interserver.net\" }' ```  ```ArrayJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": {\"name\": \"Joe\", \"email\": \"user@domain.com\"}, \"to\": [{\"name\": \"Joe\", \"email\": \"support@interserver.net\"}] }' ```  ```NameEmailJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": \"Joe <user@domain.com>\", \"to\": \"Joe <support@interserver.net>\" }' ``` 
         * @summary Sends an Email with Advanced Options
         * @param {string} subject 
         * @param {string} body 
         * @param {EmailAddressTypes} from 
         * @param {EmailAddressesTypes} to 
         * @param {EmailAddressesTypes} replyto 
         * @param {EmailAddressesTypes} cc 
         * @param {EmailAddressesTypes} bcc 
         * @param {Array<MailAttachment>} attachments 
         * @param {number} id 
         * @param {SendMailAdv} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAdvMail(subject: string, body: string, from: EmailAddressTypes, to: EmailAddressesTypes, replyto: EmailAddressesTypes, cc: EmailAddressesTypes, bcc: EmailAddressesTypes, attachments: Array<MailAttachment>, id: number, body: SendMailAdv, options: any = {}): FetchArgs {
            // verify required parameter 'subject' is not null or undefined
            if (subject === null || subject === undefined) {
                throw new RequiredError('subject','Required parameter subject was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'replyto' is not null or undefined
            if (replyto === null || replyto === undefined) {
                throw new RequiredError('replyto','Required parameter replyto was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'cc' is not null or undefined
            if (cc === null || cc === undefined) {
                throw new RequiredError('cc','Required parameter cc was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'bcc' is not null or undefined
            if (bcc === null || bcc === undefined) {
                throw new RequiredError('bcc','Required parameter bcc was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'attachments' is not null or undefined
            if (attachments === null || attachments === undefined) {
                throw new RequiredError('attachments','Required parameter attachments was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendAdvMail.');
            }
            const localVarPath = `/mail/advsend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (subject !== undefined) {
                localVarFormParams.set('subject', subject as any);
            }

            if (body !== undefined) {
                localVarFormParams.set('body', body as any);
            }

            if (from !== undefined) {
                localVarFormParams.set('from', from as any);
            }

            if (to !== undefined) {
                localVarFormParams.set('to', to as any);
            }

            if (replyto !== undefined) {
                localVarFormParams.set('replyto', replyto as any);
            }

            if (cc !== undefined) {
                localVarFormParams.set('cc', cc as any);
            }

            if (bcc !== undefined) {
                localVarFormParams.set('bcc', bcc as any);
            }

            if (attachments) {
                attachments.forEach((element) => {
                    localVarFormParams.append('attachments', element as any);
                })
            }

            if (id !== undefined) {
                localVarFormParams.set('id', id as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"SendMailAdv" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
         * @summary Sends an Email
         * @param {string} to 
         * @param {string} from 
         * @param {string} subject 
         * @param {string} body 
         * @param {SendMail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail(to: string, from: string, subject: string, body: string, body: SendMail, options: any = {}): FetchArgs {
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling sendMail.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling sendMail.');
            }
            // verify required parameter 'subject' is not null or undefined
            if (subject === null || subject === undefined) {
                throw new RequiredError('subject','Required parameter subject was null or undefined when calling sendMail.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendMail.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendMail.');
            }
            const localVarPath = `/mail/send`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (to !== undefined) {
                localVarFormParams.set('to', to as any);
            }

            if (from !== undefined) {
                localVarFormParams.set('from', from as any);
            }

            if (subject !== undefined) {
                localVarFormParams.set('subject', subject as any);
            }

            if (body !== undefined) {
                localVarFormParams.set('body', body as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"SendMail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SendingApi - functional programming interface
 * @export
 */
export const SendingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This call will let you pass the raw / complete email contents (including headers) as a string and have it get sent as-is.  This is useful for things like DKIM signed messages.
         * @summary Sends a raw email
         * @param {RawMail} body 
         * @param {string} rawEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawMail(body: RawMail, rawEmail: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericResponse> {
            const localVarFetchArgs = SendingApiFetchParamCreator(configuration).rawMail(body, rawEmail, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.  Here are 9 examples showing the various ways to call the advsend operation showing the different ways you can pass the to, cc, bcc, and replyto information. The first several examples are all for the application/x-www-form-urlencoded content-type while the later ones are for application/json content-types.  ```BasicForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data to=support@interserver.net ```  ```ArrayForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to[0][name]=Joe\" \\ --data \"to[0][email]=support@interserver.net\" ```  ```NameEmailForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=\"Joe <user@domain.com>\" \\ --data to=\"Joe <support@interserver.net>\" ```  ```MultToForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to=support@interserver.net, support@interserver.net\" ```  ```MultToFullForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to=Joe <support@interserver.net>, Joe <support@interserver.net>\" ```  ```MultToArrayForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to[0][name]=Joe\" \\ --data \"to[0][email]=support@interserver.net\" \\ --data \"to[1][name]=Joe\" \\ --data \"to[1][email]=support@interserver.net\" ```  ```BasicJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": \"user@domain.com\", \"to\": \"support@interserver.net\" }' ```  ```ArrayJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": {\"name\": \"Joe\", \"email\": \"user@domain.com\"}, \"to\": [{\"name\": \"Joe\", \"email\": \"support@interserver.net\"}] }' ```  ```NameEmailJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": \"Joe <user@domain.com>\", \"to\": \"Joe <support@interserver.net>\" }' ``` 
         * @summary Sends an Email with Advanced Options
         * @param {string} subject 
         * @param {string} body 
         * @param {EmailAddressTypes} from 
         * @param {EmailAddressesTypes} to 
         * @param {EmailAddressesTypes} replyto 
         * @param {EmailAddressesTypes} cc 
         * @param {EmailAddressesTypes} bcc 
         * @param {Array<MailAttachment>} attachments 
         * @param {number} id 
         * @param {SendMailAdv} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAdvMail(subject: string, body: string, from: EmailAddressTypes, to: EmailAddressesTypes, replyto: EmailAddressesTypes, cc: EmailAddressesTypes, bcc: EmailAddressesTypes, attachments: Array<MailAttachment>, id: number, body: SendMailAdv, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericResponse> {
            const localVarFetchArgs = SendingApiFetchParamCreator(configuration).sendAdvMail(subject, body, from, to, replyto, cc, bcc, attachments, id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
         * @summary Sends an Email
         * @param {string} to 
         * @param {string} from 
         * @param {string} subject 
         * @param {string} body 
         * @param {SendMail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail(to: string, from: string, subject: string, body: string, body: SendMail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericResponse> {
            const localVarFetchArgs = SendingApiFetchParamCreator(configuration).sendMail(to, from, subject, body, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SendingApi - factory interface
 * @export
 */
export const SendingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This call will let you pass the raw / complete email contents (including headers) as a string and have it get sent as-is.  This is useful for things like DKIM signed messages.
         * @summary Sends a raw email
         * @param {RawMail} body 
         * @param {string} rawEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawMail(body: RawMail, rawEmail: string, options?: any) {
            return SendingApiFp(configuration).rawMail(body, rawEmail, options)(fetch, basePath);
        },
        /**
         * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.  Here are 9 examples showing the various ways to call the advsend operation showing the different ways you can pass the to, cc, bcc, and replyto information. The first several examples are all for the application/x-www-form-urlencoded content-type while the later ones are for application/json content-types.  ```BasicForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data to=support@interserver.net ```  ```ArrayForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to[0][name]=Joe\" \\ --data \"to[0][email]=support@interserver.net\" ```  ```NameEmailForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=\"Joe <user@domain.com>\" \\ --data to=\"Joe <support@interserver.net>\" ```  ```MultToForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to=support@interserver.net, support@interserver.net\" ```  ```MultToFullForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to=Joe <support@interserver.net>, Joe <support@interserver.net>\" ```  ```MultToArrayForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to[0][name]=Joe\" \\ --data \"to[0][email]=support@interserver.net\" \\ --data \"to[1][name]=Joe\" \\ --data \"to[1][email]=support@interserver.net\" ```  ```BasicJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": \"user@domain.com\", \"to\": \"support@interserver.net\" }' ```  ```ArrayJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": {\"name\": \"Joe\", \"email\": \"user@domain.com\"}, \"to\": [{\"name\": \"Joe\", \"email\": \"support@interserver.net\"}] }' ```  ```NameEmailJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": \"Joe <user@domain.com>\", \"to\": \"Joe <support@interserver.net>\" }' ``` 
         * @summary Sends an Email with Advanced Options
         * @param {string} subject 
         * @param {string} body 
         * @param {EmailAddressTypes} from 
         * @param {EmailAddressesTypes} to 
         * @param {EmailAddressesTypes} replyto 
         * @param {EmailAddressesTypes} cc 
         * @param {EmailAddressesTypes} bcc 
         * @param {Array<MailAttachment>} attachments 
         * @param {number} id 
         * @param {SendMailAdv} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAdvMail(subject: string, body: string, from: EmailAddressTypes, to: EmailAddressesTypes, replyto: EmailAddressesTypes, cc: EmailAddressesTypes, bcc: EmailAddressesTypes, attachments: Array<MailAttachment>, id: number, body: SendMailAdv, options?: any) {
            return SendingApiFp(configuration).sendAdvMail(subject, body, from, to, replyto, cc, bcc, attachments, id, body, options)(fetch, basePath);
        },
        /**
         * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
         * @summary Sends an Email
         * @param {string} to 
         * @param {string} from 
         * @param {string} subject 
         * @param {string} body 
         * @param {SendMail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail(to: string, from: string, subject: string, body: string, body: SendMail, options?: any) {
            return SendingApiFp(configuration).sendMail(to, from, subject, body, body, options)(fetch, basePath);
        },
    };
};

/**
 * SendingApi - object-oriented interface
 * @export
 * @class SendingApi
 * @extends {BaseAPI}
 */
export class SendingApi extends BaseAPI {
    /**
     * This call will let you pass the raw / complete email contents (including headers) as a string and have it get sent as-is.  This is useful for things like DKIM signed messages.
     * @summary Sends a raw email
     * @param {RawMail} body 
     * @param {string} rawEmail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendingApi
     */
    public rawMail(body: RawMail, rawEmail: string, options?: any) {
        return SendingApiFp(this.configuration).rawMail(body, rawEmail, options)(this.fetch, this.basePath);
    }

    /**
     * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.  Here are 9 examples showing the various ways to call the advsend operation showing the different ways you can pass the to, cc, bcc, and replyto information. The first several examples are all for the application/x-www-form-urlencoded content-type while the later ones are for application/json content-types.  ```BasicForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data to=support@interserver.net ```  ```ArrayForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to[0][name]=Joe\" \\ --data \"to[0][email]=support@interserver.net\" ```  ```NameEmailForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=\"Joe <user@domain.com>\" \\ --data to=\"Joe <support@interserver.net>\" ```  ```MultToForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to=support@interserver.net, support@interserver.net\" ```  ```MultToFullForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to=Joe <support@interserver.net>, Joe <support@interserver.net>\" ```  ```MultToArrayForm curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data 'subject=Welcome' \\ --data 'body=Hello' \\ --data from=user@domain.com \\ --data \"to[0][name]=Joe\" \\ --data \"to[0][email]=support@interserver.net\" \\ --data \"to[1][name]=Joe\" \\ --data \"to[1][email]=support@interserver.net\" ```  ```BasicJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": \"user@domain.com\", \"to\": \"support@interserver.net\" }' ```  ```ArrayJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": {\"name\": \"Joe\", \"email\": \"user@domain.com\"}, \"to\": [{\"name\": \"Joe\", \"email\": \"support@interserver.net\"}] }' ```  ```NameEmailJson curl -i --request POST --url https://api.mailbaby.net/mail/advsend \\ --header 'Accept: application/json' \\ --header 'Content-Type: application/json' \\ --header 'X-API-KEY: YOUR_API_KEY' \\ --data '{ \"subject\": \"Welcome\", \"body\": \"Hello\", \"from\": \"Joe <user@domain.com>\", \"to\": \"Joe <support@interserver.net>\" }' ``` 
     * @summary Sends an Email with Advanced Options
     * @param {string} subject 
     * @param {string} body 
     * @param {EmailAddressTypes} from 
     * @param {EmailAddressesTypes} to 
     * @param {EmailAddressesTypes} replyto 
     * @param {EmailAddressesTypes} cc 
     * @param {EmailAddressesTypes} bcc 
     * @param {Array<MailAttachment>} attachments 
     * @param {number} id 
     * @param {SendMailAdv} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendingApi
     */
    public sendAdvMail(subject: string, body: string, from: EmailAddressTypes, to: EmailAddressesTypes, replyto: EmailAddressesTypes, cc: EmailAddressesTypes, bcc: EmailAddressesTypes, attachments: Array<MailAttachment>, id: number, body: SendMailAdv, options?: any) {
        return SendingApiFp(this.configuration).sendAdvMail(subject, body, from, to, replyto, cc, bcc, attachments, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
     * @summary Sends an Email
     * @param {string} to 
     * @param {string} from 
     * @param {string} subject 
     * @param {string} body 
     * @param {SendMail} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendingApi
     */
    public sendMail(to: string, from: string, subject: string, body: string, body: SendMail, options?: any) {
        return SendingApiFp(this.configuration).sendMail(to, from, subject, body, body, options)(this.fetch, this.basePath);
    }

}
/**
 * ServicesApi - fetch parameter creator
 * @export
 */
export const ServicesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will return a list of the mail orders you have in our system including their id, status, username, and optional comment.
         * @summary displays a list of mail service orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailOrders(options: any = {}): FetchArgs {
            const localVarPath = `/mail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This will return a list of the mail orders you have in our system including their id, status, username, and optional comment.
         * @summary displays a list of mail service orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailOrders(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MailOrder>> {
            const localVarFetchArgs = ServicesApiFetchParamCreator(configuration).getMailOrders(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This will return a list of the mail orders you have in our system including their id, status, username, and optional comment.
         * @summary displays a list of mail service orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailOrders(options?: any) {
            return ServicesApiFp(configuration).getMailOrders(options)(fetch, basePath);
        },
    };
};

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
    /**
     * This will return a list of the mail orders you have in our system including their id, status, username, and optional comment.
     * @summary displays a list of mail service orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public getMailOrders(options?: any) {
        return ServicesApiFp(this.configuration).getMailOrders(options)(this.fetch, this.basePath);
    }

}
/**
 * StatusApi - fetch parameter creator
 * @export
 */
export const StatusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Checks if the server is running
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options: any = {}): FetchArgs {
            const localVarPath = `/ping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Checks if the server is running
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StatusApiFetchParamCreator(configuration).pingServer(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Checks if the server is running
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options?: any) {
            return StatusApiFp(configuration).pingServer(options)(fetch, basePath);
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * 
     * @summary Checks if the server is running
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public pingServer(options?: any) {
        return StatusApiFp(this.configuration).pingServer(options)(this.fetch, this.basePath);
    }

}
