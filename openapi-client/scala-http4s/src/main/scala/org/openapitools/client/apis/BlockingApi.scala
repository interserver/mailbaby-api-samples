/** MailBaby Email Delivery and Management Service API
  * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
  *
  * The version of the OpenAPI document: 1.1.0
  * Contact: support@interserver.net
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.apis

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.Uri
import org.http4s.client.Client as Http4sClient
import org.openapitools.client.models.DenyRuleNewType
import org.openapitools.client.models.DenyRuleRecord
import org.openapitools.client.models.ErrorMessage
import org.openapitools.client.models.GenericResponse
import org.openapitools.client.models.MailBlocks
import scala.collection.immutable.Seq
import org.openapitools.client.models.*

trait BlockingApiEndpoints[F[*]] {

  def addRule(`type`: DenyRuleNewType, data: String, user: Option[String] = None)(using auth: _Authorization.ApiKey): F[GenericResponse]
  def deleteRule(ruleId: Int)(using auth: _Authorization.ApiKey): F[GenericResponse]
  def delistBlock(body: String)(using auth: _Authorization.ApiKey): F[GenericResponse]
  def getMailBlocks()(using auth: _Authorization.ApiKey): F[MailBlocks]
  def getRules()(using auth: _Authorization.ApiKey): F[Seq[DenyRuleRecord]]

}

class BlockingApiEndpointsImpl[F[*]: Concurrent](
  override val baseUrl: Uri,
  defaultHeaders: Seq[(String, String)] = Nil,
  httpClient: Http4sClient[F]
) extends BaseClient[F](baseUrl, defaultHeaders, httpClient) with BlockingApiEndpoints[F] {
  
  import JsonSupports.*
  import io.circe.syntax.EncoderOps
  import cats.implicits.toFlatMapOps

  override def addRule(`type`: DenyRuleNewType, data: String, user: Option[String] = None)(using auth: _Authorization.ApiKey): F[GenericResponse] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/x-www-form-urlencoded")
    ).flatten
    val formParameters = Some((
      user.map("user" -> _).map(Seq(_)) ++ 
      Some(Seq("type" -> `type`)) ++ 
      Some(Seq("data" -> data))
    ).toSeq.flatten)

    _executeRequest[Unit, GenericResponse](
      method = "POST",
      path = s"/mail/rules",
      body = None,
      formParameters = formParameters,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, GenericResponse]("GenericResponse", r)
        case r if r.status.code == 400 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def deleteRule(ruleId: Int)(using auth: _Authorization.ApiKey): F[GenericResponse] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, GenericResponse](
      method = "DELETE",
      path = s"/mail/rules/${ruleId}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, GenericResponse]("GenericResponse", r)
        case r if r.status.code == 400 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def delistBlock(body: String)(using auth: _Authorization.ApiKey): F[GenericResponse] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[String, GenericResponse](
      method = "POST",
      path = s"/mail/blocks/delete",
      body = Some(body),
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, GenericResponse]("GenericResponse", r)
        case r if r.status.code == 400 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def getMailBlocks()(using auth: _Authorization.ApiKey): F[MailBlocks] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, MailBlocks](
      method = "GET",
      path = s"/mail/blocks",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, MailBlocks]("MailBlocks", r)
        case r if r.status.code == 401 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def getRules()(using auth: _Authorization.ApiKey): F[Seq[DenyRuleRecord]] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, Seq[DenyRuleRecord]](
      method = "GET",
      path = s"/mail/rules",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, Seq[DenyRuleRecord]]("Seq[DenyRuleRecord]", r)
        case r if r.status.code == 401 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

}


