// @flow
/* eslint-disable no-use-before-define */
/**
 * MailBaby Email Delivery and Management Service API
 * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: support@interserver.net
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://api.mailbaby.net".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}


            export type DenyRuleNewTypeEnum = 'domain' | 'email' | 'startswith';
/**
 * The data for a email deny rule record.
 * @export
 */
export type DenyRuleNew = {
    /**
     * The type of deny rule.
     * @type {string}
     * @memberof DenyRuleNew
     */
    type: DenyRuleNewTypeEnum;
    /**
     * The content of the rule.  If a domain type rule then an example would be google.com. For a begins with type an example would be msgid-.  For the email typer an example would be user@server.com.
     * @type {string}
     * @memberof DenyRuleNew
     */
    data: string;
    /**
     * Mail account username that will be tied to this rule.  If not specified the first active mail order will be used.
     * @type {string}
     * @memberof DenyRuleNew
     */
    user?: string;
}


            export type DenyRuleRecordTypeEnum = 'domain' | 'email' | 'startswith';
/**
 * The data for a email deny rule record.
 * @export
 */
export type DenyRuleRecord = {
    /**
     * The deny rule Id number.
     * @type {number}
     * @memberof DenyRuleRecord
     */
    id: number;
    /**
     * the date the rule was created.
     * @type {Date}
     * @memberof DenyRuleRecord
     */
    created: Date;
    /**
     * The type of deny rule.
     * @type {string}
     * @memberof DenyRuleRecord
     */
    type: DenyRuleRecordTypeEnum;
    /**
     * The content of the rule.  If a domain type rule then an example would be google.com. For a begins with type an example would be msgid-.  For the email typer an example would be user@server.com.
     * @type {string}
     * @memberof DenyRuleRecord
     */
    data: string;
    /**
     * Mail account username that will be tied to this rule.  If not specified the first active mail order will be used.
     * @type {string}
     * @memberof DenyRuleRecord
     */
    user?: string;
}

/**
 * 
 * @export
 */
export type DenyRuleRecordAllOf = {
    /**
     * The deny rule Id number.
     * @type {number}
     * @memberof DenyRuleRecordAllOf
     */
    id: number;
    /**
     * the date the rule was created.
     * @type {Date}
     * @memberof DenyRuleRecordAllOf
     */
    created: Date;
}

/**
 * an email address
 * @export
 */
export type EmailAddress = {
    /**
     * an email address
     * @type {string}
     * @memberof EmailAddress
     */
    email?: string;
}

/**
 * 
 * @export
 */
export type GenericResponse = {
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    text?: string;
}

/**
 * 
 * @export
 */
export type GetMailOrders401Response = {
    /**
     * 
     * @type {string}
     * @memberof GetMailOrders401Response
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof GetMailOrders401Response
     */
    message: string;
}

/**
 * 
 * @export
 */
export type GetStats200ResponseInner = {
    /**
     * 
     * @type {number}
     * @memberof GetStats200ResponseInner
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof GetStats200ResponseInner
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof GetStats200ResponseInner
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof GetStats200ResponseInner
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof GetStats200ResponseInner
     */
    comment?: string;
}

/**
 * A block entry from the clickhouse mailblocks server.
 * @export
 */
export type MailBlockClickHouse = {
    /**
     * 
     * @type {Date}
     * @memberof MailBlockClickHouse
     */
    _date: Date;
    /**
     * 
     * @type {string}
     * @memberof MailBlockClickHouse
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof MailBlockClickHouse
     */
    messageId: string;
    /**
     * 
     * @type {string}
     * @memberof MailBlockClickHouse
     */
    subject: string;
    /**
     * 
     * @type {string}
     * @memberof MailBlockClickHouse
     */
    to: string;
}

/**
 * This is a block entry from the rspamd block list.
 * @export
 */
export type MailBlockRspamd = {
    /**
     * 
     * @type {string}
     * @memberof MailBlockRspamd
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof MailBlockRspamd
     */
    subject: string;
}

/**
 * The listing of blocked emails.
 * @export
 */
export type MailBlocks = {
    /**
     * 
     * @type {Array<MailBlockClickHouse>}
     * @memberof MailBlocks
     */
    local: Array<MailBlockClickHouse>;
    /**
     * 
     * @type {Array<MailBlockClickHouse>}
     * @memberof MailBlocks
     */
    mbtrap: Array<MailBlockClickHouse>;
    /**
     * 
     * @type {Array<MailBlockRspamd>}
     * @memberof MailBlocks
     */
    subject: Array<MailBlockRspamd>;
}

/**
 * Mail log records
 * @export
 */
export type MailLog = {
    /**
     * total number of mail log entries
     * @type {number}
     * @memberof MailLog
     */
    total: number;
    /**
     * number of emails skipped in listing
     * @type {number}
     * @memberof MailLog
     */
    skip: number;
    /**
     * number of emails to return
     * @type {number}
     * @memberof MailLog
     */
    limit: number;
    /**
     * 
     * @type {Array<MailLogEntry>}
     * @memberof MailLog
     */
    emails: Array<MailLogEntry>;
}

/**
 * An email record
 * @export
 */
export type MailLogEntry = {
    /**
     * internal db id
     * @type {number}
     * @memberof MailLogEntry
     */
    _id: number;
    /**
     * mail id
     * @type {string}
     * @memberof MailLogEntry
     */
    id: string;
    /**
     * from address
     * @type {string}
     * @memberof MailLogEntry
     */
    from: string;
    /**
     * to address
     * @type {string}
     * @memberof MailLogEntry
     */
    to: string;
    /**
     * email subject
     * @type {string}
     * @memberof MailLogEntry
     */
    subject: string;
    /**
     * creation date
     * @type {string}
     * @memberof MailLogEntry
     */
    created: string;
    /**
     * creation timestamp
     * @type {number}
     * @memberof MailLogEntry
     */
    time: number;
    /**
     * user account
     * @type {string}
     * @memberof MailLogEntry
     */
    user: string;
    /**
     * transaction type
     * @type {string}
     * @memberof MailLogEntry
     */
    transtype: string;
    /**
     * origin ip
     * @type {string}
     * @memberof MailLogEntry
     */
    origin: string;
    /**
     * interface name
     * @type {string}
     * @memberof MailLogEntry
     */
    _interface: string;
    /**
     * sending zone
     * @type {string}
     * @memberof MailLogEntry
     */
    sendingZone: string;
    /**
     * email body size in bytes
     * @type {number}
     * @memberof MailLogEntry
     */
    bodySize: number;
    /**
     * index of email in the to adderess list
     * @type {number}
     * @memberof MailLogEntry
     */
    seq: number;
    /**
     * to address this email is being sent to
     * @type {string}
     * @memberof MailLogEntry
     */
    recipient: string;
    /**
     * to address domain
     * @type {string}
     * @memberof MailLogEntry
     */
    domain: string;
    /**
     * locked status
     * @type {number}
     * @memberof MailLogEntry
     */
    locked: number;
    /**
     * lock timestamp
     * @type {number}
     * @memberof MailLogEntry
     */
    lockTime: number;
    /**
     * assigned server
     * @type {string}
     * @memberof MailLogEntry
     */
    assigned: string;
    /**
     * queued timestamp
     * @type {string}
     * @memberof MailLogEntry
     */
    queued: string;
    /**
     * mx hostname
     * @type {string}
     * @memberof MailLogEntry
     */
    mxHostname: string;
    /**
     * mail delivery response
     * @type {string}
     * @memberof MailLogEntry
     */
    response: string;
    /**
     * message id
     * @type {string}
     * @memberof MailLogEntry
     */
    messageId?: string;
}

/**
 * A mail order record
 * @export
 */
export type MailOrder = {
    /**
     * The ID of the order.
     * @type {number}
     * @memberof MailOrder
     */
    id: number;
    /**
     * The order status.
     * @type {string}
     * @memberof MailOrder
     */
    status: string;
    /**
     * The username to use for this order.
     * @type {string}
     * @memberof MailOrder
     */
    username: string;
    /**
     * Optional order comment.
     * @type {string}
     * @memberof MailOrder
     */
    comment?: string;
}

/**
 * Details for an Email
 * @export
 */
export type SendMail = {
    /**
     * The Contact whom is the primary recipient of this email.
     * @type {string}
     * @memberof SendMail
     */
    to: string;
    /**
     * The contact whom is the this email is from.
     * @type {string}
     * @memberof SendMail
     */
    from: string;
    /**
     * The subject or title of the email
     * @type {string}
     * @memberof SendMail
     */
    subject: string;
    /**
     * The main email contents.
     * @type {string}
     * @memberof SendMail
     */
    body: string;
}

/**
 * Details for an Email
 * @export
 */
export type SendMailAdv = {
    /**
     * The subject or title of the email
     * @type {string}
     * @memberof SendMailAdv
     */
    subject: string;
    /**
     * The main email contents.
     * @type {string}
     * @memberof SendMailAdv
     */
    body: string;
    /**
     * 
     * @type {EmailAddressName}
     * @memberof SendMailAdv
     */
    from: EmailAddressName;
    /**
     * A list of destionation email addresses to send this to
     * @type {Array<EmailAddressName>}
     * @memberof SendMailAdv
     */
    to: Array<EmailAddressName>;
    /**
     * (optional) A list of email addresses that specify where replies to the email should be sent instead of the _from_ address.
     * @type {Array<EmailAddressName>}
     * @memberof SendMailAdv
     */
    replyto?: Array<EmailAddressName>;
    /**
     * (optional) A list of email addresses to carbon copy this message to.  They are listed on the email and anyone getting the email can see this full list of Contacts who received the email as well.
     * @type {Array<EmailAddressName>}
     * @memberof SendMailAdv
     */
    cc?: Array<EmailAddressName>;
    /**
     * (optional) list of email addresses that should receive copies of the email.  They are hidden on the email and anyone gettitng the email would not see the other people getting the email in this list.
     * @type {Array<EmailAddressName>}
     * @memberof SendMailAdv
     */
    bcc?: Array<EmailAddressName>;
    /**
     * (optional) File attachments to include in the email.  The file contents must be base64 encoded!
     * @type {Array<MailAttachment>}
     * @memberof SendMailAdv
     */
    attachments?: Array<MailAttachment>;
    /**
     * (optional)  ID of the Mail order within our system to use as the Mail Account.
     * @type {number}
     * @memberof SendMailAdv
     */
    id?: number;
}



/**
 * BlockingApi - fetch parameter creator
 * @export
 */
export const BlockingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new email deny rule into the system to block new emails that match the given criteria
         * @summary Creates a new email deny rule.
         * @throws {RequiredError}
         */
        addRule(type: string, data: string, user?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling addRule.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling addRule.');
            }
            const localVarPath = `/mail/rules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (user !== undefined) {
                localVarFormParams.set('user', ((user:any):string));
            }

            if (type !== undefined) {
                localVarFormParams.set('type', ((type:any):string));
            }

            if (data !== undefined) {
                localVarFormParams.set('data', ((data:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes one of the configured deny mail rules from the system.
         * @summary Removes an deny mail rule.
         * @throws {RequiredError}
         */
        deleteRule(ruleId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling deleteRule.');
            }
            const localVarPath = `/mail/rules/{ruleId}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an email address from the various block lists. 
         * @summary Removes an email address from the blocked list
         * @throws {RequiredError}
         */
        delistBlock(emailAddress: EmailAddress, options: RequestOptions): FetchArgs {
            // verify required parameter 'emailAddress' is not null or undefined
            if (emailAddress === null || emailAddress === undefined) {
                throw new RequiredError('emailAddress','Required parameter emailAddress was null or undefined when calling delistBlock.');
            }
            const localVarPath = `/mail/blocks/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof emailAddress !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailAddress != null ? emailAddress : {}) : (((emailAddress:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary displays a list of blocked email addresses
         * @throws {RequiredError}
         */
        getMailBlocks(options: RequestOptions): FetchArgs {
            const localVarPath = `/mail/blocks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a listing of all the deny block rules you have configured.
         * @summary Displays a listing of deny email rules.
         * @throws {RequiredError}
         */
        getRules(options: RequestOptions): FetchArgs {
            const localVarPath = `/mail/rules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type BlockingApiType = { 
    addRule(type: string, data: string, user?: string, options?: RequestOptions): Promise<GenericResponse>,

    deleteRule(ruleId: number, options?: RequestOptions): Promise<GenericResponse>,

    delistBlock(emailAddress: EmailAddress, options?: RequestOptions): Promise<GenericResponse>,

    getMailBlocks(options?: RequestOptions): Promise<MailBlocks>,

    getRules(options?: RequestOptions): Promise<Array<DenyRuleRecord>>,
}

/**
 * BlockingApi - factory function to inject configuration 
 * @export
 */
export const BlockingApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): BlockingApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Adds a new email deny rule into the system to block new emails that match the given criteria
         * @summary Creates a new email deny rule.
         * @throws {RequiredError}
         */
        addRule(type: string, data: string, user?: string, options?: RequestOptions = {}): Promise<GenericResponse> {
            const localVarFetchArgs = BlockingApiFetchParamCreator(configuration).addRule(type, data, user, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Removes one of the configured deny mail rules from the system.
         * @summary Removes an deny mail rule.
         * @throws {RequiredError}
         */
        deleteRule(ruleId: number, options?: RequestOptions = {}): Promise<GenericResponse> {
            const localVarFetchArgs = BlockingApiFetchParamCreator(configuration).deleteRule(ruleId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Removes an email address from the various block lists. 
         * @summary Removes an email address from the blocked list
         * @throws {RequiredError}
         */
        delistBlock(emailAddress: EmailAddress, options?: RequestOptions = {}): Promise<GenericResponse> {
            const localVarFetchArgs = BlockingApiFetchParamCreator(configuration).delistBlock(emailAddress, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary displays a list of blocked email addresses
         * @throws {RequiredError}
         */
        getMailBlocks(options?: RequestOptions = {}): Promise<MailBlocks> {
            const localVarFetchArgs = BlockingApiFetchParamCreator(configuration).getMailBlocks(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Returns a listing of all the deny block rules you have configured.
         * @summary Displays a listing of deny email rules.
         * @throws {RequiredError}
         */
        getRules(options?: RequestOptions = {}): Promise<Array<DenyRuleRecord>> {
            const localVarFetchArgs = BlockingApiFetchParamCreator(configuration).getRules(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * HistoryApi - fetch parameter creator
 * @export
 */
export const HistoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary displays a list of blocked email addresses
         * @throws {RequiredError}
         */
        getStats(options: RequestOptions): FetchArgs {
            const localVarPath = `/mail/stats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a listing of the emails sent through this system 
         * @summary displays the mail log
         * @throws {RequiredError}
         */
        viewMailLog(id?: number, origin?: string, mx?: string, from?: string, to?: string, subject?: string, mailid?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/mail/log`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = ((origin:any):string);
            }

            if (mx !== undefined) {
                localVarQueryParameter['mx'] = ((mx:any):string);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = ((from:any):string);
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = ((to:any):string);
            }

            if (subject !== undefined) {
                localVarQueryParameter['subject'] = ((subject:any):string);
            }

            if (mailid !== undefined) {
                localVarQueryParameter['mailid'] = ((mailid:any):string);
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = ((skip:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):string);
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type HistoryApiType = { 
    getStats(options?: RequestOptions): Promise<Array<GetStats200ResponseInner>>,

    viewMailLog(id?: number, origin?: string, mx?: string, from?: string, to?: string, subject?: string, mailid?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, options?: RequestOptions): Promise<MailLog>,
}

/**
 * HistoryApi - factory function to inject configuration 
 * @export
 */
export const HistoryApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): HistoryApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary displays a list of blocked email addresses
         * @throws {RequiredError}
         */
        getStats(options?: RequestOptions = {}): Promise<Array<GetStats200ResponseInner>> {
            const localVarFetchArgs = HistoryApiFetchParamCreator(configuration).getStats(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get a listing of the emails sent through this system 
         * @summary displays the mail log
         * @throws {RequiredError}
         */
        viewMailLog(id?: number, origin?: string, mx?: string, from?: string, to?: string, subject?: string, mailid?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, options?: RequestOptions = {}): Promise<MailLog> {
            const localVarFetchArgs = HistoryApiFetchParamCreator(configuration).viewMailLog(id, origin, mx, from, to, subject, mailid, skip, limit, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * SendingApi - fetch parameter creator
 * @export
 */
export const SendingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.
         * @summary Sends an Email with Advanced Options
         * @throws {RequiredError}
         */
        sendAdvMail(subject: string, body: string, from: EmailAddressName, to: Array<EmailAddressName>, replyto?: Array<EmailAddressName>, cc?: Array<EmailAddressName>, bcc?: Array<EmailAddressName>, attachments?: Array<MailAttachment>, id?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'subject' is not null or undefined
            if (subject === null || subject === undefined) {
                throw new RequiredError('subject','Required parameter subject was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling sendAdvMail.');
            }
            const localVarPath = `/mail/advsend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (subject !== undefined) {
                localVarFormParams.set('subject', ((subject:any):string));
            }

            if (body !== undefined) {
                localVarFormParams.set('body', ((body:any):string));
            }

            if (from !== undefined) {
                localVarFormParams.set('from', ((from:any):string));
            }

            if (to) {
                    localVarFormParams.set('to', to.join(COLLECTION_FORMATS["csv"]));
            }

            if (replyto) {
                    localVarFormParams.set('replyto', replyto.join(COLLECTION_FORMATS["csv"]));
            }

            if (cc) {
                    localVarFormParams.set('cc', cc.join(COLLECTION_FORMATS["csv"]));
            }

            if (bcc) {
                    localVarFormParams.set('bcc', bcc.join(COLLECTION_FORMATS["csv"]));
            }

            if (attachments) {
                    localVarFormParams.set('attachments', attachments.join(COLLECTION_FORMATS["csv"]));
            }

            if (id !== undefined) {
                localVarFormParams.set('id', ((id:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
         * @summary Sends an Email
         * @throws {RequiredError}
         */
        sendMail(to: string, from: string, subject: string, body: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling sendMail.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling sendMail.');
            }
            // verify required parameter 'subject' is not null or undefined
            if (subject === null || subject === undefined) {
                throw new RequiredError('subject','Required parameter subject was null or undefined when calling sendMail.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendMail.');
            }
            const localVarPath = `/mail/send`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (to !== undefined) {
                localVarFormParams.set('to', ((to:any):string));
            }

            if (from !== undefined) {
                localVarFormParams.set('from', ((from:any):string));
            }

            if (subject !== undefined) {
                localVarFormParams.set('subject', ((subject:any):string));
            }

            if (body !== undefined) {
                localVarFormParams.set('body', ((body:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SendingApiType = { 
    sendAdvMail(subject: string, body: string, from: EmailAddressName, to: Array<EmailAddressName>, replyto?: Array<EmailAddressName>, cc?: Array<EmailAddressName>, bcc?: Array<EmailAddressName>, attachments?: Array<MailAttachment>, id?: number, options?: RequestOptions): Promise<GenericResponse>,

    sendMail(to: string, from: string, subject: string, body: string, options?: RequestOptions): Promise<GenericResponse>,
}

/**
 * SendingApi - factory function to inject configuration 
 * @export
 */
export const SendingApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SendingApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.
         * @summary Sends an Email with Advanced Options
         * @throws {RequiredError}
         */
        sendAdvMail(subject: string, body: string, from: EmailAddressName, to: Array<EmailAddressName>, replyto?: Array<EmailAddressName>, cc?: Array<EmailAddressName>, bcc?: Array<EmailAddressName>, attachments?: Array<MailAttachment>, id?: number, options?: RequestOptions = {}): Promise<GenericResponse> {
            const localVarFetchArgs = SendingApiFetchParamCreator(configuration).sendAdvMail(subject, body, from, to, replyto, cc, bcc, attachments, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
         * @summary Sends an Email
         * @throws {RequiredError}
         */
        sendMail(to: string, from: string, subject: string, body: string, options?: RequestOptions = {}): Promise<GenericResponse> {
            const localVarFetchArgs = SendingApiFetchParamCreator(configuration).sendMail(to, from, subject, body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ServicesApi - fetch parameter creator
 * @export
 */
export const ServicesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will return a list of the mail orders you have in our system including their id, status, username, and optional comment.
         * @summary displays a list of mail service orders
         * @throws {RequiredError}
         */
        getMailOrders(options: RequestOptions): FetchArgs {
            const localVarPath = `/mail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ServicesApiType = { 
    getMailOrders(options?: RequestOptions): Promise<Array<MailOrder>>,
}

/**
 * ServicesApi - factory function to inject configuration 
 * @export
 */
export const ServicesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ServicesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * This will return a list of the mail orders you have in our system including their id, status, username, and optional comment.
         * @summary displays a list of mail service orders
         * @throws {RequiredError}
         */
        getMailOrders(options?: RequestOptions = {}): Promise<Array<MailOrder>> {
            const localVarFetchArgs = ServicesApiFetchParamCreator(configuration).getMailOrders(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * StatusApi - fetch parameter creator
 * @export
 */
export const StatusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Checks if the server is running
         * @throws {RequiredError}
         */
        pingServer(options: RequestOptions): FetchArgs {
            const localVarPath = `/ping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type StatusApiType = { 
    pingServer(options?: RequestOptions): Promise<Response>,
}

/**
 * StatusApi - factory function to inject configuration 
 * @export
 */
export const StatusApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): StatusApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Checks if the server is running
         * @throws {RequiredError}
         */
        pingServer(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = StatusApiFetchParamCreator(configuration).pingServer(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    BlockingApi: BlockingApiType,

    HistoryApi: HistoryApiType,

    SendingApi: SendingApiType,

    ServicesApi: ServicesApiType,

    StatusApi: StatusApiType,
 }
