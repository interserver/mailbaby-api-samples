extends ApiBee
class_name HistoryApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API HistoryApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "HistoryApi"


# Operation getStats → GET /mail/stats
# Account usage statistics.
#
# Returns information about the usage on your mail accounts.
func get_stats(
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/mail/stats"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = getStats_200_response_inner.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_stats_threaded(
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_stats")
	bzz_callable.bind(
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation viewMailLog → GET /mail/log
# displays the mail log
#
# Get a listing of the emails sent through this system 
func view_mail_log(
	# id: float   Eg: 2604
	# The ID of your mail order this will be sent through.
	id = null,
	# origin: String = ""   Eg: 1.2.3.4
	# originating ip address sending mail
	origin = "",
	# mx: String = ""   Eg: mx.google.com
	# mx record mail was sent to
	mx = "",
	# from: String = ""   Eg: me@sender.com
	# from email address
	from = "",
	# to: String = ""   Eg: you@receiver.com
	# to/destination email address
	to = "",
	# subject: String = ""   Eg: Support
	# subject containing this string
	subject = "",
	# mailid: String = ""   Eg: 185997065c60008840
	# mail id
	mailid = "",
	# skip: int = 0   Eg: 1000
	# number of records to skip for pagination
	skip = 0,
	# limit: int = 100   Eg: 1000
	# maximum number of records to return
	limit = 100,
	# startDate: float   Eg: 1641781008
	# earliest date to get emails in unix timestamp format
	startDate = null,
	# endDate: float   Eg: 1673317008
	# earliest date to get emails in unix timestamp format
	endDate = null,
	# replyto: String = ""   Eg: replyto_example
	# Reply-To Email Address
	replyto = "",
	# headerfrom: String = ""   Eg: headerfrom_example
	# Header From Email Address
	headerfrom = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Validate param `skip` constraints
	if skip < 0:
		var error := ApiError.new()
		error.identifier = "view_mail_log.param.validation.minimum"
		error.message = "Invalid value for `skip`, must be greater than or equal to 0."
		on_failure.call(error)
		return

	# Validate param `limit` constraints
	if limit > 10000:
		var error := ApiError.new()
		error.identifier = "view_mail_log.param.validation.maximum"
		error.message = "Invalid value for `limit`, must be smaller than or equal to 10000."
		on_failure.call(error)
		return
	if limit < 1:
		var error := ApiError.new()
		error.identifier = "view_mail_log.param.validation.minimum"
		error.message = "Invalid value for `limit`, must be greater than or equal to 1."
		on_failure.call(error)
		return

	# Validate param `startDate` constraints
	if startDate > 9999999999:
		var error := ApiError.new()
		error.identifier = "view_mail_log.param.validation.maximum"
		error.message = "Invalid value for `startDate`, must be smaller than or equal to 9999999999."
		on_failure.call(error)
		return
	if startDate < 0:
		var error := ApiError.new()
		error.identifier = "view_mail_log.param.validation.minimum"
		error.message = "Invalid value for `startDate`, must be greater than or equal to 0."
		on_failure.call(error)
		return

	# Validate param `endDate` constraints
	if endDate > 9999999999:
		var error := ApiError.new()
		error.identifier = "view_mail_log.param.validation.maximum"
		error.message = "Invalid value for `endDate`, must be smaller than or equal to 9999999999."
		on_failure.call(error)
		return
	if endDate < 0:
		var error := ApiError.new()
		error.identifier = "view_mail_log.param.validation.minimum"
		error.message = "Invalid value for `endDate`, must be greater than or equal to 0."
		on_failure.call(error)
		return

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/mail/log"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["id"] = id
	bzz_query["origin"] = origin
	bzz_query["mx"] = mx
	bzz_query["from"] = from
	bzz_query["to"] = to
	bzz_query["subject"] = subject
	bzz_query["mailid"] = mailid
	bzz_query["skip"] = skip
	bzz_query["limit"] = limit
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["replyto"] = replyto
	bzz_query["headerfrom"] = headerfrom

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MailLog.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func view_mail_log_threaded(
	# id: float   Eg: 2604
	# The ID of your mail order this will be sent through.
	id = null,
	# origin: String = ""   Eg: 1.2.3.4
	# originating ip address sending mail
	origin = "",
	# mx: String = ""   Eg: mx.google.com
	# mx record mail was sent to
	mx = "",
	# from: String = ""   Eg: me@sender.com
	# from email address
	from = "",
	# to: String = ""   Eg: you@receiver.com
	# to/destination email address
	to = "",
	# subject: String = ""   Eg: Support
	# subject containing this string
	subject = "",
	# mailid: String = ""   Eg: 185997065c60008840
	# mail id
	mailid = "",
	# skip: int = 0   Eg: 1000
	# number of records to skip for pagination
	skip = 0,
	# limit: int = 100   Eg: 1000
	# maximum number of records to return
	limit = 100,
	# startDate: float   Eg: 1641781008
	# earliest date to get emails in unix timestamp format
	startDate = null,
	# endDate: float   Eg: 1673317008
	# earliest date to get emails in unix timestamp format
	endDate = null,
	# replyto: String = ""   Eg: replyto_example
	# Reply-To Email Address
	replyto = "",
	# headerfrom: String = ""   Eg: headerfrom_example
	# Header From Email Address
	headerfrom = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "view_mail_log")
	bzz_callable.bind(
		id,
		origin,
		mx,
		from,
		to,
		subject,
		mailid,
		skip,
		limit,
		startDate,
		endDate,
		replyto,
		headerfrom,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


