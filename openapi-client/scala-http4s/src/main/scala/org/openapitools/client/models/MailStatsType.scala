/** MailBaby Email Delivery and Management Service API
  * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
  *
  * The version of the OpenAPI document: 1.1.0
  * Contact: support@interserver.net
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.models

import io.circe.*
import io.circe.syntax.*
import io.circe.{Decoder, Encoder}


/** Statistics about the mail usage including volume by IP, To address, and From address; as well as total sent / delivered counts and cost.
  * @param time 
  * @param usage 
  * @param currency 
  * @param currencySymbol 
  * @param cost 
  * @param received 
  * @param sent 
  * @param volume 
  */
case class MailStatsType(
    time: Option[MailStatsTypeTime] = None,
    usage: Option[Int] = None,
    currency: Option[String] = None,
    currencySymbol: Option[String] = None,
    cost: Option[Double] = None,
    received: Option[Int] = None,
    sent: Option[Int] = None,
    volume: Option[MailStatsTypeVolume] = None
)
  
object MailStatsType {
  given encoderMailStatsType: Encoder[MailStatsType] = Encoder.instance { t =>
    Json.fromFields{
      Seq(
        t.time.map(v => "time" -> v.asJson),
        t.usage.map(v => "usage" -> v.asJson),
        t.currency.map(v => "currency" -> v.asJson),
        t.currencySymbol.map(v => "currencySymbol" -> v.asJson),
        t.cost.map(v => "cost" -> v.asJson),
        t.received.map(v => "received" -> v.asJson),
        t.sent.map(v => "sent" -> v.asJson),
        t.volume.map(v => "volume" -> v.asJson)
      ).flatten
    }
  }
  given decoderMailStatsType: Decoder[MailStatsType] = Decoder.instance { c =>
    for {
      time <- mapEmptyStringToNull(c.downField("time")).as[Option[MailStatsTypeTime]]
      usage <- c.downField("usage").as[Option[Int]]
      currency <- c.downField("currency").as[Option[String]]
      currencySymbol <- c.downField("currencySymbol").as[Option[String]]
      cost <- c.downField("cost").as[Option[Double]]
      received <- c.downField("received").as[Option[Int]]
      sent <- c.downField("sent").as[Option[Int]]
      volume <- c.downField("volume").as[Option[MailStatsTypeVolume]]
    } yield MailStatsType(
      time = time,
      usage = usage,
      currency = currency,
      currencySymbol = currencySymbol,
      cost = cost,
      received = received,
      sent = sent,
      volume = volume
    )
  }
}

