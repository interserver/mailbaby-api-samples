/**
 * MailBaby Email Delivery and Management Service API
 * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
 *
 * OpenAPI spec version: 1.3.0
 * Contact: support@interserver.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.ErrorMessage
import io.swagger.client.models.MailLog
import io.swagger.client.models.MailStatsType

import io.swagger.client.infrastructure.*

class HistoryApi(basePath: kotlin.String = "https://api.mailbaby.net") : ApiClient(basePath) {

    /**
     * Account usage statistics.
     * Returns information about the usage on your mail accounts.
     * @param time The timeframe for the statistics. (optional)
     * @return MailStatsType
     */
    @Suppress("UNCHECKED_CAST")
    fun getStats(time: kotlin.String? = null): MailStatsType {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (time != null) {
                put("time", listOf(time.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/mail/stats", query = localVariableQuery
        )
        val response = request<MailStatsType>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as MailStatsType
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * displays the mail log
     * Get a listing of the emails sent through this system 
     * @param id The ID of your mail order this will be sent through. (optional)
     * @param origin originating ip address sending mail (optional)
     * @param mx mx record mail was sent to (optional)
     * @param from from email address (optional)
     * @param to to/destination email address (optional)
     * @param subject subject containing this string (optional)
     * @param mailid mail id (optional)
     * @param skip number of records to skip for pagination (optional, default to 0)
     * @param limit maximum number of records to return (optional, default to 100)
     * @param startDate earliest date to get emails in unix timestamp format (optional)
     * @param endDate earliest date to get emails in unix timestamp format (optional)
     * @param replyto Reply-To Email Address (optional)
     * @param headerfrom Header From Email Address (optional)
     * @param delivered Limiting the emails to wether or not they were delivered. (optional)
     * @return MailLog
     */
    @Suppress("UNCHECKED_CAST")
    fun viewMailLog(id: kotlin.Long? = null, origin: kotlin.String? = null, mx: kotlin.String? = null, from: kotlin.String? = null, to: kotlin.String? = null, subject: kotlin.String? = null, mailid: kotlin.String? = null, skip: kotlin.Int? = null, limit: kotlin.Int? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, replyto: kotlin.String? = null, headerfrom: kotlin.String? = null, delivered: kotlin.String? = null): MailLog {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (id != null) {
                put("id", listOf(id.toString()))
            }
            if (origin != null) {
                put("origin", listOf(origin.toString()))
            }
            if (mx != null) {
                put("mx", listOf(mx.toString()))
            }
            if (from != null) {
                put("from", listOf(from.toString()))
            }
            if (to != null) {
                put("to", listOf(to.toString()))
            }
            if (subject != null) {
                put("subject", listOf(subject.toString()))
            }
            if (mailid != null) {
                put("mailid", listOf(mailid.toString()))
            }
            if (skip != null) {
                put("skip", listOf(skip.toString()))
            }
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
            if (startDate != null) {
                put("startDate", listOf(startDate.toString()))
            }
            if (endDate != null) {
                put("endDate", listOf(endDate.toString()))
            }
            if (replyto != null) {
                put("replyto", listOf(replyto.toString()))
            }
            if (headerfrom != null) {
                put("headerfrom", listOf(headerfrom.toString()))
            }
            if (delivered != null) {
                put("delivered", listOf(delivered.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/mail/log", query = localVariableQuery
        )
        val response = request<MailLog>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as MailLog
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
