# #MailBaby Email Delivery and Management Service API
#
##**Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
#
#The version of the OpenAPI document: 1.3.0
#Contact: support@interserver.net
#Generated by: https://openapi-generator.tech
#Generator version: 7.19.0
#

module OpenAPIClient
  # 
  class EmailAddressesTypes
    include JSON::Serializable
    include YAML::Serializable

    class SchemaMismatchError < Exception
    end

    # List of class defined in oneOf (OpenAPI v3)
    def self.openapi_one_of
      [
        Array(EmailAddressName),
        String
      ]
    end



    def self.build(data)
      openapi_one_of.each do |klass|
        begin
          typed_data = find_and_cast_into_type(klass, data)
          return typed_data if typed_data
        rescue ex
          # rescue all errors so we keep iterating even if the current item lookup raises
          Log.trace { ex.message }
        end
      end

      nil
    end

    private def self.find_and_cast_into_type(klass : Array(EmailAddressName).class, data)
      return if data.nil?

      Log.trace { "INSPECTING DATA" }
      Log.trace { data.inspect }

      case data
      when NetboxClient::RecursiveHash
        if value = cast_value(array_data: false, array_class: array_class?(klass), klass: klass, data: data)
          return new(value)
        end
      when Array(NetboxClient::RecursiveHash)
        if value = cast_value(array_data: true, array_class: array_class?(klass), klass: klass, data: data)
          return new(value)
        end
      else
        raise SchemaMismatchError.new("#{data} doesn't match the #{klass} type")
      end
    end
    private def self.find_and_cast_into_type(klass : String.class, data)
      return if data.nil?

      Log.trace { "INSPECTING DATA" }
      Log.trace { data.inspect }

      case data
      when NetboxClient::RecursiveHash
        if value = cast_value(array_data: false, array_class: array_class?(klass), klass: klass, data: data)
          return new(value)
        end
      when Array(NetboxClient::RecursiveHash)
        if value = cast_value(array_data: true, array_class: array_class?(klass), klass: klass, data: data)
          return new(value)
        end
      else
        raise SchemaMismatchError.new("#{data} doesn't match the #{klass} type")
      end
    end

    private def self.cast_value(array_data : Bool, array_class : Bool, klass, data)
      if array_class == true && array_data == true
        Log.debug { "Building array of classes: #{klass} / #{data}" }

        klass.from_json(data.to_json)
      elsif array_class == false && array_data == false
        Log.debug { "Building single class: #{klass} / #{data}" }

        klass.from_json(data.to_json)
      end
    end

    private def self.array_class?(klass)
      klass.name.starts_with?("Array(")
    end

    def initialize(@value : Array(EmailAddressName))
    end

    def initialize(@value : String)
    end


    delegate :to_yaml, to: @value
    delegate :to_json, to: @value

    def to_any_h
      {"value" => to_h}
    end

    def to_h
      val = @value
      if val.is_a?(Int32)
        val
      else
        val.to_h
      end
    end
  end

end
