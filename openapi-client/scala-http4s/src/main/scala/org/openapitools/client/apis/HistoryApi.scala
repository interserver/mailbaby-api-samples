/** MailBaby Email Delivery and Management Service API
  * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
  *
  * The version of the OpenAPI document: 1.1.0
  * Contact: support@interserver.net
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.apis

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.Uri
import org.http4s.client.Client as Http4sClient
import org.openapitools.client.models.ErrorMessage
import org.openapitools.client.models.GetStats200ResponseInner
import org.openapitools.client.models.MailLog
import scala.collection.immutable.Seq
import org.openapitools.client.models.*

trait HistoryApiEndpoints[F[*]] {

  def getStats()(using auth: _Authorization.ApiKey): F[Seq[GetStats200ResponseInner]]
  def viewMailLog(id: Option[Long] = None, origin: Option[String] = None, mx: Option[String] = None, from: Option[String] = None, to: Option[String] = None, subject: Option[String] = None, mailid: Option[String] = None, skip: Option[Int] = None, limit: Option[Int] = None, startDate: Option[Long] = None, endDate: Option[Long] = None, replyto: Option[String] = None, headerfrom: Option[String] = None)(using auth: _Authorization.ApiKey): F[MailLog]

}

class HistoryApiEndpointsImpl[F[*]: Concurrent](
  override val baseUrl: Uri,
  defaultHeaders: Seq[(String, String)] = Nil,
  httpClient: Http4sClient[F]
) extends BaseClient[F](baseUrl, defaultHeaders, httpClient) with HistoryApiEndpoints[F] {
  
  import JsonSupports.*
  import io.circe.syntax.EncoderOps
  import cats.implicits.toFlatMapOps

  override def getStats()(using auth: _Authorization.ApiKey): F[Seq[GetStats200ResponseInner]] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, Seq[GetStats200ResponseInner]](
      method = "GET",
      path = s"/mail/stats",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, Seq[GetStats200ResponseInner]]("Seq[GetStats200ResponseInner]", r)
        case r if r.status.code == 401 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, ErrorMessage]("ErrorMessage", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def viewMailLog(id: Option[Long] = None, origin: Option[String] = None, mx: Option[String] = None, from: Option[String] = None, to: Option[String] = None, subject: Option[String] = None, mailid: Option[String] = None, skip: Option[Int] = None, limit: Option[Int] = None, startDate: Option[Long] = None, endDate: Option[Long] = None, replyto: Option[String] = None, headerfrom: Option[String] = None)(using auth: _Authorization.ApiKey): F[MailLog] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten
    val queryParameters = (
      id.map("id" -> _).map(Seq(_)) ++ 
      origin.map("origin" -> _).map(Seq(_)) ++ 
      mx.map("mx" -> _).map(Seq(_)) ++ 
      from.map("from" -> _).map(Seq(_)) ++ 
      to.map("to" -> _).map(Seq(_)) ++ 
      subject.map("subject" -> _).map(Seq(_)) ++ 
      mailid.map("mailid" -> _).map(Seq(_)) ++ 
      skip.map("skip" -> _).map(Seq(_)) ++ 
      limit.map("limit" -> _).map(Seq(_)) ++ 
      startDate.map("startDate" -> _).map(Seq(_)) ++ 
      endDate.map("endDate" -> _).map(Seq(_)) ++ 
      replyto.map("replyto" -> _).map(Seq(_)) ++ 
      headerfrom.map("headerfrom" -> _).map(Seq(_))
    ).toSeq.flatten

    _executeRequest[Unit, MailLog](
      method = "GET",
      path = s"/mail/log",
      body = None,
      formParameters = None,
      queryParameters = queryParameters,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, MailLog]("MailLog", r)
        case r if r.status.code == 400 => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason))
    }
  }

}


