<?php
/**
 * SendingApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Interserver\Mailbaby
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * MailBaby Email Delivery and Management Service API
 *
 * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: support@interserver.net
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Interserver\Mailbaby\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Interserver\Mailbaby\ApiException;
use Interserver\Mailbaby\Configuration;
use Interserver\Mailbaby\HeaderSelector;
use Interserver\Mailbaby\ObjectSerializer;

/**
 * SendingApi Class Doc Comment
 *
 * @category Class
 * @package  Interserver\Mailbaby
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SendingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'sendAdvMail' => [
            'application/x-www-form-urlencoded',
            'application/json',
        ],
        'sendMail' => [
            'application/x-www-form-urlencoded',
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation sendAdvMail
     *
     * Sends an Email with Advanced Options
     *
     * @param  string $subject The subject or title of the email (required)
     * @param  string $body The main email contents. (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName $from from (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $to A list of destionation email addresses to send this to (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $replyto (optional) A list of email addresses that specify where replies to the email should be sent instead of the _from_ address. (optional)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $cc (optional) A list of email addresses to carbon copy this message to.  They are listed on the email and anyone getting the email can see this full list of Contacts who received the email as well. (optional)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $bcc (optional) list of email addresses that should receive copies of the email.  They are hidden on the email and anyone gettitng the email would not see the other people getting the email in this list. (optional)
     * @param  \Interserver\Mailbaby\Model\MailAttachment[] $attachments (optional) File attachments to include in the email.  The file contents must be base64 encoded! (optional)
     * @param  int $id (optional)  ID of the Mail order within our system to use as the Mail Account. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendAdvMail'] to see the possible values for this operation
     *
     * @throws \Interserver\Mailbaby\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Interserver\Mailbaby\Model\GenericResponse|\Interserver\Mailbaby\Model\GetMailOrders401Response|\Interserver\Mailbaby\Model\GetMailOrders401Response|\Interserver\Mailbaby\Model\GetMailOrders401Response
     */
    public function sendAdvMail($subject, $body, $from, $to, $replyto = null, $cc = null, $bcc = null, $attachments = null, $id = null, string $contentType = self::contentTypes['sendAdvMail'][0])
    {
        list($response) = $this->sendAdvMailWithHttpInfo($subject, $body, $from, $to, $replyto, $cc, $bcc, $attachments, $id, $contentType);
        return $response;
    }

    /**
     * Operation sendAdvMailWithHttpInfo
     *
     * Sends an Email with Advanced Options
     *
     * @param  string $subject The subject or title of the email (required)
     * @param  string $body The main email contents. (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName $from (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $to A list of destionation email addresses to send this to (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $replyto (optional) A list of email addresses that specify where replies to the email should be sent instead of the _from_ address. (optional)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $cc (optional) A list of email addresses to carbon copy this message to.  They are listed on the email and anyone getting the email can see this full list of Contacts who received the email as well. (optional)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $bcc (optional) list of email addresses that should receive copies of the email.  They are hidden on the email and anyone gettitng the email would not see the other people getting the email in this list. (optional)
     * @param  \Interserver\Mailbaby\Model\MailAttachment[] $attachments (optional) File attachments to include in the email.  The file contents must be base64 encoded! (optional)
     * @param  int $id (optional)  ID of the Mail order within our system to use as the Mail Account. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendAdvMail'] to see the possible values for this operation
     *
     * @throws \Interserver\Mailbaby\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Interserver\Mailbaby\Model\GenericResponse|\Interserver\Mailbaby\Model\GetMailOrders401Response|\Interserver\Mailbaby\Model\GetMailOrders401Response|\Interserver\Mailbaby\Model\GetMailOrders401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendAdvMailWithHttpInfo($subject, $body, $from, $to, $replyto = null, $cc = null, $bcc = null, $attachments = null, $id = null, string $contentType = self::contentTypes['sendAdvMail'][0])
    {
        $request = $this->sendAdvMailRequest($subject, $body, $from, $to, $replyto, $cc, $bcc, $attachments, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Interserver\Mailbaby\Model\GenericResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Interserver\Mailbaby\Model\GenericResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Interserver\Mailbaby\Model\GenericResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Interserver\Mailbaby\Model\GetMailOrders401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Interserver\Mailbaby\Model\GetMailOrders401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Interserver\Mailbaby\Model\GetMailOrders401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Interserver\Mailbaby\Model\GenericResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Interserver\Mailbaby\Model\GenericResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Interserver\Mailbaby\Model\GetMailOrders401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Interserver\Mailbaby\Model\GetMailOrders401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Interserver\Mailbaby\Model\GetMailOrders401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendAdvMailAsync
     *
     * Sends an Email with Advanced Options
     *
     * @param  string $subject The subject or title of the email (required)
     * @param  string $body The main email contents. (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName $from (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $to A list of destionation email addresses to send this to (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $replyto (optional) A list of email addresses that specify where replies to the email should be sent instead of the _from_ address. (optional)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $cc (optional) A list of email addresses to carbon copy this message to.  They are listed on the email and anyone getting the email can see this full list of Contacts who received the email as well. (optional)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $bcc (optional) list of email addresses that should receive copies of the email.  They are hidden on the email and anyone gettitng the email would not see the other people getting the email in this list. (optional)
     * @param  \Interserver\Mailbaby\Model\MailAttachment[] $attachments (optional) File attachments to include in the email.  The file contents must be base64 encoded! (optional)
     * @param  int $id (optional)  ID of the Mail order within our system to use as the Mail Account. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendAdvMail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendAdvMailAsync($subject, $body, $from, $to, $replyto = null, $cc = null, $bcc = null, $attachments = null, $id = null, string $contentType = self::contentTypes['sendAdvMail'][0])
    {
        return $this->sendAdvMailAsyncWithHttpInfo($subject, $body, $from, $to, $replyto, $cc, $bcc, $attachments, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendAdvMailAsyncWithHttpInfo
     *
     * Sends an Email with Advanced Options
     *
     * @param  string $subject The subject or title of the email (required)
     * @param  string $body The main email contents. (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName $from (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $to A list of destionation email addresses to send this to (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $replyto (optional) A list of email addresses that specify where replies to the email should be sent instead of the _from_ address. (optional)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $cc (optional) A list of email addresses to carbon copy this message to.  They are listed on the email and anyone getting the email can see this full list of Contacts who received the email as well. (optional)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $bcc (optional) list of email addresses that should receive copies of the email.  They are hidden on the email and anyone gettitng the email would not see the other people getting the email in this list. (optional)
     * @param  \Interserver\Mailbaby\Model\MailAttachment[] $attachments (optional) File attachments to include in the email.  The file contents must be base64 encoded! (optional)
     * @param  int $id (optional)  ID of the Mail order within our system to use as the Mail Account. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendAdvMail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendAdvMailAsyncWithHttpInfo($subject, $body, $from, $to, $replyto = null, $cc = null, $bcc = null, $attachments = null, $id = null, string $contentType = self::contentTypes['sendAdvMail'][0])
    {
        $returnType = '\Interserver\Mailbaby\Model\GenericResponse';
        $request = $this->sendAdvMailRequest($subject, $body, $from, $to, $replyto, $cc, $bcc, $attachments, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendAdvMail'
     *
     * @param  string $subject The subject or title of the email (required)
     * @param  string $body The main email contents. (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName $from (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $to A list of destionation email addresses to send this to (required)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $replyto (optional) A list of email addresses that specify where replies to the email should be sent instead of the _from_ address. (optional)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $cc (optional) A list of email addresses to carbon copy this message to.  They are listed on the email and anyone getting the email can see this full list of Contacts who received the email as well. (optional)
     * @param  \Interserver\Mailbaby\Model\EmailAddressName[] $bcc (optional) list of email addresses that should receive copies of the email.  They are hidden on the email and anyone gettitng the email would not see the other people getting the email in this list. (optional)
     * @param  \Interserver\Mailbaby\Model\MailAttachment[] $attachments (optional) File attachments to include in the email.  The file contents must be base64 encoded! (optional)
     * @param  int $id (optional)  ID of the Mail order within our system to use as the Mail Account. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendAdvMail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendAdvMailRequest($subject, $body, $from, $to, $replyto = null, $cc = null, $bcc = null, $attachments = null, $id = null, string $contentType = self::contentTypes['sendAdvMail'][0])
    {

        // verify the required parameter 'subject' is set
        if ($subject === null || (is_array($subject) && count($subject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subject when calling sendAdvMail'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling sendAdvMail'
            );
        }

        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling sendAdvMail'
            );
        }

        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling sendAdvMail'
            );
        }







        $resourcePath = '/mail/advsend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($subject !== null) {
            $formParams['subject'] = ObjectSerializer::toFormValue($subject);
        }
        // form params
        if ($body !== null) {
            $formParams['body'] = ObjectSerializer::toFormValue($body);
        }
        // form params
        if ($from !== null) {
            $formParams['from'] = ObjectSerializer::toFormValue($from);
        }
        // form params
        if ($to !== null) {
            $formParams['to'] = ObjectSerializer::toFormValue($to);
        }
        // form params
        if ($replyto !== null) {
            $formParams['replyto'] = ObjectSerializer::toFormValue($replyto);
        }
        // form params
        if ($cc !== null) {
            $formParams['cc'] = ObjectSerializer::toFormValue($cc);
        }
        // form params
        if ($bcc !== null) {
            $formParams['bcc'] = ObjectSerializer::toFormValue($bcc);
        }
        // form params
        if ($attachments !== null) {
            $formParams['attachments'] = ObjectSerializer::toFormValue($attachments);
        }
        // form params
        if ($id !== null) {
            $formParams['id'] = ObjectSerializer::toFormValue($id);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendMail
     *
     * Sends an Email
     *
     * @param  string $to The Contact whom is the primary recipient of this email. (required)
     * @param  string $from The contact whom is the this email is from. (required)
     * @param  string $subject The subject or title of the email (required)
     * @param  string $body The main email contents. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendMail'] to see the possible values for this operation
     *
     * @throws \Interserver\Mailbaby\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Interserver\Mailbaby\Model\GenericResponse|\Interserver\Mailbaby\Model\GetMailOrders401Response|\Interserver\Mailbaby\Model\GetMailOrders401Response|\Interserver\Mailbaby\Model\GetMailOrders401Response
     */
    public function sendMail($to, $from, $subject, $body, string $contentType = self::contentTypes['sendMail'][0])
    {
        list($response) = $this->sendMailWithHttpInfo($to, $from, $subject, $body, $contentType);
        return $response;
    }

    /**
     * Operation sendMailWithHttpInfo
     *
     * Sends an Email
     *
     * @param  string $to The Contact whom is the primary recipient of this email. (required)
     * @param  string $from The contact whom is the this email is from. (required)
     * @param  string $subject The subject or title of the email (required)
     * @param  string $body The main email contents. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendMail'] to see the possible values for this operation
     *
     * @throws \Interserver\Mailbaby\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Interserver\Mailbaby\Model\GenericResponse|\Interserver\Mailbaby\Model\GetMailOrders401Response|\Interserver\Mailbaby\Model\GetMailOrders401Response|\Interserver\Mailbaby\Model\GetMailOrders401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendMailWithHttpInfo($to, $from, $subject, $body, string $contentType = self::contentTypes['sendMail'][0])
    {
        $request = $this->sendMailRequest($to, $from, $subject, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Interserver\Mailbaby\Model\GenericResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Interserver\Mailbaby\Model\GenericResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Interserver\Mailbaby\Model\GenericResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Interserver\Mailbaby\Model\GetMailOrders401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Interserver\Mailbaby\Model\GetMailOrders401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Interserver\Mailbaby\Model\GetMailOrders401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Interserver\Mailbaby\Model\GetMailOrders401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Interserver\Mailbaby\Model\GenericResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Interserver\Mailbaby\Model\GenericResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Interserver\Mailbaby\Model\GetMailOrders401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Interserver\Mailbaby\Model\GetMailOrders401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Interserver\Mailbaby\Model\GetMailOrders401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendMailAsync
     *
     * Sends an Email
     *
     * @param  string $to The Contact whom is the primary recipient of this email. (required)
     * @param  string $from The contact whom is the this email is from. (required)
     * @param  string $subject The subject or title of the email (required)
     * @param  string $body The main email contents. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendMail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendMailAsync($to, $from, $subject, $body, string $contentType = self::contentTypes['sendMail'][0])
    {
        return $this->sendMailAsyncWithHttpInfo($to, $from, $subject, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendMailAsyncWithHttpInfo
     *
     * Sends an Email
     *
     * @param  string $to The Contact whom is the primary recipient of this email. (required)
     * @param  string $from The contact whom is the this email is from. (required)
     * @param  string $subject The subject or title of the email (required)
     * @param  string $body The main email contents. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendMail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendMailAsyncWithHttpInfo($to, $from, $subject, $body, string $contentType = self::contentTypes['sendMail'][0])
    {
        $returnType = '\Interserver\Mailbaby\Model\GenericResponse';
        $request = $this->sendMailRequest($to, $from, $subject, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendMail'
     *
     * @param  string $to The Contact whom is the primary recipient of this email. (required)
     * @param  string $from The contact whom is the this email is from. (required)
     * @param  string $subject The subject or title of the email (required)
     * @param  string $body The main email contents. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendMail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendMailRequest($to, $from, $subject, $body, string $contentType = self::contentTypes['sendMail'][0])
    {

        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling sendMail'
            );
        }

        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling sendMail'
            );
        }

        // verify the required parameter 'subject' is set
        if ($subject === null || (is_array($subject) && count($subject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subject when calling sendMail'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling sendMail'
            );
        }


        $resourcePath = '/mail/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($to !== null) {
            $formParams['to'] = ObjectSerializer::toFormValue($to);
        }
        // form params
        if ($from !== null) {
            $formParams['from'] = ObjectSerializer::toFormValue($from);
        }
        // form params
        if ($subject !== null) {
            $formParams['subject'] = ObjectSerializer::toFormValue($subject);
        }
        // form params
        if ($body !== null) {
            $formParams['body'] = ObjectSerializer::toFormValue($body);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
