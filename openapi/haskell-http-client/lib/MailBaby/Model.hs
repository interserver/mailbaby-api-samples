{-
   Mail Baby API

   This is an API for accesssing the mail services.

   OpenAPI Version: 3.0.0
   Mail Baby API API version: 1.0.0
   Contact: detain@interserver.net
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : MailBaby.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module MailBaby.Model where

import MailBaby.Core
import MailBaby.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Body
newtype Body = Body { unBody :: Text } deriving (P.Eq, P.Show)

-- ** From
newtype From = From { unFrom :: Text } deriving (P.Eq, P.Show)

-- ** FromName
newtype FromName = FromName { unFromName :: Text } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Integer } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** SearchString
newtype SearchString = SearchString { unSearchString :: Text } deriving (P.Eq, P.Show)

-- ** Skip
newtype Skip = Skip { unSkip :: Int } deriving (P.Eq, P.Show)

-- ** Subject
newtype Subject = Subject { unSubject :: Text } deriving (P.Eq, P.Show)

-- ** To
newtype To = To { unTo :: Text } deriving (P.Eq, P.Show)

-- ** ToName
newtype ToName = ToName { unToName :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** ErrorResponse
-- | ErrorResponse
data ErrorResponse = ErrorResponse
  { errorResponseCode :: !(Text) -- ^ /Required/ "code"
  , errorResponseMessage :: !(Text) -- ^ /Required/ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:  "code")
      <*> (o .:  "message")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "code" .= errorResponseCode
      , "message" .= errorResponseMessage
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: Text -- ^ 'errorResponseCode' 
  -> Text -- ^ 'errorResponseMessage' 
  -> ErrorResponse
mkErrorResponse errorResponseCode errorResponseMessage =
  ErrorResponse
  { errorResponseCode
  , errorResponseMessage
  }

-- ** GenericResponse
-- | GenericResponse
data GenericResponse = GenericResponse
  { genericResponseStatus :: !(Maybe Text) -- ^ "status"
  , genericResponseStatusText :: !(Maybe Text) -- ^ "status_text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenericResponse
instance A.FromJSON GenericResponse where
  parseJSON = A.withObject "GenericResponse" $ \o ->
    GenericResponse
      <$> (o .:? "status")
      <*> (o .:? "status_text")

-- | ToJSON GenericResponse
instance A.ToJSON GenericResponse where
  toJSON GenericResponse {..} =
   _omitNulls
      [ "status" .= genericResponseStatus
      , "status_text" .= genericResponseStatusText
      ]


-- | Construct a value of type 'GenericResponse' (by applying it's required fields, if any)
mkGenericResponse
  :: GenericResponse
mkGenericResponse =
  GenericResponse
  { genericResponseStatus = Nothing
  , genericResponseStatusText = Nothing
  }

-- ** MailAttachment
-- | MailAttachment
-- A File attachment for an email
data MailAttachment = MailAttachment
  { mailAttachmentFilename :: !(Maybe Text) -- ^ "filename" - Optional filename to specify for the attachment.
  , mailAttachmentData :: !(FilePath) -- ^ /Required/ "data" - Contents of the attached file
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MailAttachment
instance A.FromJSON MailAttachment where
  parseJSON = A.withObject "MailAttachment" $ \o ->
    MailAttachment
      <$> (o .:? "filename")
      <*> (o .:  "data")

-- | ToJSON MailAttachment
instance A.ToJSON MailAttachment where
  toJSON MailAttachment {..} =
   _omitNulls
      [ "filename" .= mailAttachmentFilename
      , "data" .= mailAttachmentData
      ]


-- | Construct a value of type 'MailAttachment' (by applying it's required fields, if any)
mkMailAttachment
  :: FilePath -- ^ 'mailAttachmentData': Contents of the attached file
  -> MailAttachment
mkMailAttachment mailAttachmentData =
  MailAttachment
  { mailAttachmentFilename = Nothing
  , mailAttachmentData
  }

-- ** MailContact
-- | MailContact
-- An Email Contact
data MailContact = MailContact
  { mailContactEmail :: !(Text) -- ^ /Required/ "email" - The email address
  , mailContactName :: !(Maybe Text) -- ^ "name" - Optional contact name
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MailContact
instance A.FromJSON MailContact where
  parseJSON = A.withObject "MailContact" $ \o ->
    MailContact
      <$> (o .:  "email")
      <*> (o .:? "name")

-- | ToJSON MailContact
instance A.ToJSON MailContact where
  toJSON MailContact {..} =
   _omitNulls
      [ "email" .= mailContactEmail
      , "name" .= mailContactName
      ]


-- | Construct a value of type 'MailContact' (by applying it's required fields, if any)
mkMailContact
  :: Text -- ^ 'mailContactEmail': The email address
  -> MailContact
mkMailContact mailContactEmail =
  MailContact
  { mailContactEmail
  , mailContactName = Nothing
  }

-- ** MailLog
-- | MailLog
-- Mail Order Details
data MailLog = MailLog
  { mailLogId :: !(Maybe Integer) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MailLog
instance A.FromJSON MailLog where
  parseJSON = A.withObject "MailLog" $ \o ->
    MailLog
      <$> (o .:? "id")

-- | ToJSON MailLog
instance A.ToJSON MailLog where
  toJSON MailLog {..} =
   _omitNulls
      [ "id" .= mailLogId
      ]


-- | Construct a value of type 'MailLog' (by applying it's required fields, if any)
mkMailLog
  :: MailLog
mkMailLog =
  MailLog
  { mailLogId = Nothing
  }

-- ** MailOrder
-- | MailOrder
data MailOrder = MailOrder
  { mailOrderId :: !(Int) -- ^ /Required/ "id"
  , mailOrderStatus :: !(Text) -- ^ /Required/ "status"
  , mailOrderUsername :: !(Text) -- ^ /Required/ "username"
  , mailOrderPassword :: !(Maybe Text) -- ^ "password"
  , mailOrderComment :: !(Maybe Text) -- ^ "comment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MailOrder
instance A.FromJSON MailOrder where
  parseJSON = A.withObject "MailOrder" $ \o ->
    MailOrder
      <$> (o .:  "id")
      <*> (o .:  "status")
      <*> (o .:  "username")
      <*> (o .:? "password")
      <*> (o .:? "comment")

-- | ToJSON MailOrder
instance A.ToJSON MailOrder where
  toJSON MailOrder {..} =
   _omitNulls
      [ "id" .= mailOrderId
      , "status" .= mailOrderStatus
      , "username" .= mailOrderUsername
      , "password" .= mailOrderPassword
      , "comment" .= mailOrderComment
      ]


-- | Construct a value of type 'MailOrder' (by applying it's required fields, if any)
mkMailOrder
  :: Int -- ^ 'mailOrderId' 
  -> Text -- ^ 'mailOrderStatus' 
  -> Text -- ^ 'mailOrderUsername' 
  -> MailOrder
mkMailOrder mailOrderId mailOrderStatus mailOrderUsername =
  MailOrder
  { mailOrderId
  , mailOrderStatus
  , mailOrderUsername
  , mailOrderPassword = Nothing
  , mailOrderComment = Nothing
  }

-- ** SendMail
-- | SendMail
-- Details for an Email
data SendMail = SendMail
  { sendMailId :: !(Integer) -- ^ /Required/ "id" - The ID of the Mail order within our system to use as the Mail Account.
  , sendMailFrom :: !(MailContact) -- ^ /Required/ "from"
  , sendMailTo :: !([MailContact]) -- ^ /Required/ "to" - The Contact whom is the primary recipient of this email.
  , sendMailSubject :: !(Text) -- ^ /Required/ "subject" - The subject or title of the email
  , sendMailBody :: !(Text) -- ^ /Required/ "body" - The main email contents.
  , sendMailReplyto :: !(Maybe [MailContact]) -- ^ "replyto" - Optional list of Contacts that specify where replies to the email should be sent instead of the _from_ address.
  , sendMailCc :: !(Maybe [MailContact]) -- ^ "cc" - Optional list of Contacts that should receive copies of the email.  They are listed on the email and anyone getting the email can see this full list of Contacts who received the email as well.
  , sendMailBcc :: !(Maybe [MailContact]) -- ^ "bcc" - Optional list of Contacts that should receive copies of the email.  They are hidden on the email and anyone gettitng the email would not see the other people getting the email in this list.
  , sendMailAttachments :: !(Maybe [MailAttachment]) -- ^ "attachments" - Optional file attachments to include in the email
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendMail
instance A.FromJSON SendMail where
  parseJSON = A.withObject "SendMail" $ \o ->
    SendMail
      <$> (o .:  "id")
      <*> (o .:  "from")
      <*> (o .:  "to")
      <*> (o .:  "subject")
      <*> (o .:  "body")
      <*> (o .:? "replyto")
      <*> (o .:? "cc")
      <*> (o .:? "bcc")
      <*> (o .:? "attachments")

-- | ToJSON SendMail
instance A.ToJSON SendMail where
  toJSON SendMail {..} =
   _omitNulls
      [ "id" .= sendMailId
      , "from" .= sendMailFrom
      , "to" .= sendMailTo
      , "subject" .= sendMailSubject
      , "body" .= sendMailBody
      , "replyto" .= sendMailReplyto
      , "cc" .= sendMailCc
      , "bcc" .= sendMailBcc
      , "attachments" .= sendMailAttachments
      ]


-- | Construct a value of type 'SendMail' (by applying it's required fields, if any)
mkSendMail
  :: Integer -- ^ 'sendMailId': The ID of the Mail order within our system to use as the Mail Account.
  -> MailContact -- ^ 'sendMailFrom' 
  -> [MailContact] -- ^ 'sendMailTo': The Contact whom is the primary recipient of this email.
  -> Text -- ^ 'sendMailSubject': The subject or title of the email
  -> Text -- ^ 'sendMailBody': The main email contents.
  -> SendMail
mkSendMail sendMailId sendMailFrom sendMailTo sendMailSubject sendMailBody =
  SendMail
  { sendMailId
  , sendMailFrom
  , sendMailTo
  , sendMailSubject
  , sendMailBody
  , sendMailReplyto = Nothing
  , sendMailCc = Nothing
  , sendMailBcc = Nothing
  , sendMailAttachments = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyApiKeyAuth
data AuthApiKeyApiKeyAuth =
  AuthApiKeyApiKeyAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKeyAuth where
  applyAuthMethod _ a@(AuthApiKeyApiKeyAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-API-KEY", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyApiLoginAuth
data AuthApiKeyApiLoginAuth =
  AuthApiKeyApiLoginAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiLoginAuth where
  applyAuthMethod _ a@(AuthApiKeyApiLoginAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-API-LOGIN", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyApiPasswordAuth
data AuthApiKeyApiPasswordAuth =
  AuthApiKeyApiPasswordAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiPasswordAuth where
  applyAuthMethod _ a@(AuthApiKeyApiPasswordAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-API-PASS", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


