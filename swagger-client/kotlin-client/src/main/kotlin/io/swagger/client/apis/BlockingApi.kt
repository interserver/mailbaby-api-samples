/**
 * MailBaby Email Delivery and Management Service API
 * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.** # Overview This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net). # Authentication In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site. We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
 *
 * OpenAPI spec version: 1.3.0
 * Contact: support@interserver.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.DenyRuleNew
import io.swagger.client.models.DenyRuleRecord
import io.swagger.client.models.ErrorMessage
import io.swagger.client.models.GenericResponse
import io.swagger.client.models.MailBlocks

import io.swagger.client.infrastructure.*

class BlockingApi(basePath: kotlin.String = "https://api.mailbaby.net") : ApiClient(basePath) {

    /**
     * Creates a new email deny rule.
     * Adds a new email deny rule into the system to block new emails that match the given criteria
     * @param user  
     * @param type  
     * @param &#x60;data&#x60;  
     * @return GenericResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun addRule(user: kotlin.String, type: kotlin.String, &#x60;data&#x60;: kotlin.String): GenericResponse {
        val localVariableBody: kotlin.Any? = mapOf("user" to "$user", "type" to "$type", "data" to "$&#x60;data&#x60;")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/mail/rules", headers = localVariableHeaders
        )
        val response = request<GenericResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GenericResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Creates a new email deny rule.
     * Adds a new email deny rule into the system to block new emails that match the given criteria
     * @param body These are the fields needed to create a new email deny rule. 
     * @return GenericResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun addRule(body: DenyRuleNew): GenericResponse {
        val localVariableBody: kotlin.Any? = body
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/mail/rules", headers = localVariableHeaders
        )
        val response = request<GenericResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GenericResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Removes an deny mail rule.
     * Removes one of the configured deny mail rules from the system.
     * @param ruleId The ID of the Rules entry. 
     * @return GenericResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun deleteRule(ruleId: kotlin.Int): GenericResponse {
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/mail/rules/{ruleId}".replace("{" + "ruleId" + "}", "$ruleId")
        )
        val response = request<GenericResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GenericResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Removes an email address from the blocked list
     * Removes an email address from the various block lists. 
     * @param body  
     * @return GenericResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun delistBlock(body: kotlin.String): GenericResponse {
        val localVariableBody: kotlin.Any? = body
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/mail/blocks/delete"
        )
        val response = request<GenericResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GenericResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * displays a list of blocked email addresses
     * 
     * @return MailBlocks
     */
    @Suppress("UNCHECKED_CAST")
    fun getMailBlocks(): MailBlocks {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/mail/blocks"
        )
        val response = request<MailBlocks>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as MailBlocks
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Displays a listing of deny email rules.
     * Returns a listing of all the deny block rules you have configured.
     * @return kotlin.Array<DenyRuleRecord>
     */
    @Suppress("UNCHECKED_CAST")
    fun getRules(): kotlin.Array<DenyRuleRecord> {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/mail/rules"
        )
        val response = request<kotlin.Array<DenyRuleRecord>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<DenyRuleRecord>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
