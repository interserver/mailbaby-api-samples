/**
 * MailBaby Email Delivery API
 * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.**   # üìå Overview  This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net).   # üîê Authentication  In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site.  We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
 *
 * OpenAPI spec version: 1.0.1
 * Contact: support@interserver.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.GenericResponse
import io.swagger.client.models.InlineResponse200
import io.swagger.client.models.InlineResponse401
import io.swagger.client.models.MailLog
import io.swagger.client.models.SendMail
import io.swagger.client.models.SendMailAdv
import io.swagger.client.models.SendMailAdvAttachments
import io.swagger.client.models.SendMailAdvBcc
import io.swagger.client.models.SendMailAdvCc
import io.swagger.client.models.SendMailAdvFrom
import io.swagger.client.models.SendMailAdvReplyto
import io.swagger.client.models.SendMailAdvTo

import io.swagger.client.infrastructure.*

class DefaultApi(basePath: kotlin.String = "https://api.mailbaby.net") : ApiClient(basePath) {

    /**
     * displays a list of mail service orders
     * 
     * @return kotlin.Array<InlineResponse200>
     */
    @Suppress("UNCHECKED_CAST")
    fun getMailOrders(): kotlin.Array<InlineResponse200> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/mail"
        )
        val response = request<kotlin.Array<InlineResponse200>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<InlineResponse200>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Checks if the server is running
     * 
     * @return void
     */
    fun pingServer(): Unit {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/ping"
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Sends an Email with Advanced Options
     * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.
     * @param body  
     * @return GenericResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun sendAdvMail(body: SendMailAdv): GenericResponse {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableHeaders: kotlin.collections.Map<kotlin.String, kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/mail/advsend", headers = localVariableHeaders
        )
        val response = request<GenericResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GenericResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Sends an Email with Advanced Options
     * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.
     * @param subject  
     * @param body  
     * @param from  
     * @param to  
     * @param replyto  
     * @param cc  
     * @param bcc  
     * @param attachments  
     * @param id  
     * @return GenericResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun sendAdvMail(subject: kotlin.String, body: kotlin.String, from: SendMailAdvFrom, to: kotlin.Array<SendMailAdvTo>, replyto: kotlin.Array<SendMailAdvReplyto>, cc: kotlin.Array<SendMailAdvCc>, bcc: kotlin.Array<SendMailAdvBcc>, attachments: kotlin.Array<SendMailAdvAttachments>, id: kotlin.Long): GenericResponse {
        val localVariableBody: kotlin.Any? = mapOf("subject" to "$subject", "body" to "$body", "from" to "$from", "to" to "$to", "replyto" to "$replyto", "cc" to "$cc", "bcc" to "$bcc", "attachments" to "$attachments", "id" to "$id")
        
        val localVariableHeaders: kotlin.collections.Map<kotlin.String, kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/mail/advsend", headers = localVariableHeaders
        )
        val response = request<GenericResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GenericResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Sends an Email
     * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
     * @param to  
     * @param from  
     * @param subject  
     * @param body  
     * @return GenericResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun sendMail(to: kotlin.String, from: kotlin.String, subject: kotlin.String, body: kotlin.String): GenericResponse {
        val localVariableBody: kotlin.Any? = mapOf("to" to "$to", "from" to "$from", "subject" to "$subject", "body" to "$body")
        
        val localVariableHeaders: kotlin.collections.Map<kotlin.String, kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/mail/send", headers = localVariableHeaders
        )
        val response = request<GenericResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GenericResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Sends an Email
     * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
     * @param body  
     * @return GenericResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun sendMail(body: SendMail): GenericResponse {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableHeaders: kotlin.collections.Map<kotlin.String, kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/mail/send", headers = localVariableHeaders
        )
        val response = request<GenericResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GenericResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * displays the mail log
     * By passing in the appropriate options, you can search for available inventory in the system 
     * @param id The ID of your mail order this will be sent through. (optional)
     * @param search pass an optional search string for looking up inventory (optional)
     * @param skip number of records to skip for pagination (optional, default to 0)
     * @param limit maximum number of records to return (optional, default to 100)
     * @param startDate earliest date to get emails in unix timestamp format (optional)
     * @param endDate earliest date to get emails in unix timestamp format (optional)
     * @return MailLog
     */
    @Suppress("UNCHECKED_CAST")
    fun viewMailLog(id: kotlin.Long? = null, search: kotlin.String? = null, skip: kotlin.Int? = null, limit: kotlin.Int? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null): MailLog {
        val localVariableQuery: MultiValueMap = mapOf("id" to listOf("$id"), "search" to listOf("$search"), "skip" to listOf("$skip"), "limit" to listOf("$limit"), "startDate" to listOf("$startDate"), "endDate" to listOf("$endDate"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/mail/log", query = localVariableQuery
        )
        val response = request<MailLog>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as MailLog
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
