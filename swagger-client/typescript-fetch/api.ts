/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MailBaby Email Delivery API
 * **Send emails fast and with confidence through our easy to use [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API interface.**   # üìå Overview  This is the API interface to the [Mail Baby](https//mail.baby/) Mail services provided by [InterServer](https://www.interserver.net). To use this service you must have an account with us at [my.interserver.net](https://my.interserver.net).   # üîê Authentication  In order to use most of the API calls you must pass credentials from the [my.interserver.net](https://my.interserver.net/) site.  We support several different authentication methods but the preferred method is to use the **API Key** which you can get from the [Account Security](https://my.interserver.net/account_security) page. 
 *
 * OpenAPI spec version: 1.0.1
 * Contact: support@interserver.net
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.mailbaby.net".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface GenericResponse
 */
export interface GenericResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    text?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    comment?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse401
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse401
     */
    message: string;
}
/**
 * Mail log records
 * @export
 * @interface MailLog
 */
export interface MailLog {
    /**
     * total number of mail log entries
     * @type {number}
     * @memberof MailLog
     */
    total: number;
    /**
     * number of emails skipped in listing
     * @type {number}
     * @memberof MailLog
     */
    skip: number;
    /**
     * number of emails to return
     * @type {number}
     * @memberof MailLog
     */
    limit: number;
    /**
     * 
     * @type {Array<MailLogEntry>}
     * @memberof MailLog
     */
    emails: Array<MailLogEntry>;
}
/**
 * An email record
 * @export
 * @interface MailLogEntry
 */
export interface MailLogEntry {
    /**
     * internal db id
     * @type {number}
     * @memberof MailLogEntry
     */
    id: number;
    /**
     * mail id
     * @type {string}
     * @memberof MailLogEntry
     */
    id: string;
    /**
     * from address
     * @type {string}
     * @memberof MailLogEntry
     */
    from: string;
    /**
     * to address
     * @type {string}
     * @memberof MailLogEntry
     */
    to: string;
    /**
     * email subject
     * @type {string}
     * @memberof MailLogEntry
     */
    subject: string;
    /**
     * message id
     * @type {string}
     * @memberof MailLogEntry
     */
    messageId: string;
    /**
     * creation date
     * @type {string}
     * @memberof MailLogEntry
     */
    created: string;
    /**
     * creation timestamp
     * @type {number}
     * @memberof MailLogEntry
     */
    time: number;
    /**
     * user account
     * @type {string}
     * @memberof MailLogEntry
     */
    user: string;
    /**
     * transaction type
     * @type {string}
     * @memberof MailLogEntry
     */
    transtype: string;
    /**
     * transaction host
     * @type {string}
     * @memberof MailLogEntry
     */
    transhost: string;
    /**
     * origin host
     * @type {string}
     * @memberof MailLogEntry
     */
    originhost: string;
    /**
     * origin ip
     * @type {string}
     * @memberof MailLogEntry
     */
    origin: string;
    /**
     * interface name
     * @type {string}
     * @memberof MailLogEntry
     */
    _interface: string;
    /**
     * date processed
     * @type {string}
     * @memberof MailLogEntry
     */
    date: string;
    /**
     * sending zone
     * @type {string}
     * @memberof MailLogEntry
     */
    sendingZone: string;
    /**
     * email body size in bytes
     * @type {number}
     * @memberof MailLogEntry
     */
    bodySize: number;
    /**
     * md5 sum of the email
     * @type {string}
     * @memberof MailLogEntry
     */
    sourceMd5: string;
    /**
     * delivery sequency
     * @type {number}
     * @memberof MailLogEntry
     */
    seq: number;
    /**
     * to address domain
     * @type {string}
     * @memberof MailLogEntry
     */
    domain: string;
    /**
     * email receiver address
     * @type {string}
     * @memberof MailLogEntry
     */
    recipient: string;
    /**
     * locked status
     * @type {number}
     * @memberof MailLogEntry
     */
    locked: number;
    /**
     * lock timestamp
     * @type {number}
     * @memberof MailLogEntry
     */
    lockTime: number;
    /**
     * assigned server
     * @type {string}
     * @memberof MailLogEntry
     */
    assigned: string;
    /**
     * queued timestamp
     * @type {string}
     * @memberof MailLogEntry
     */
    queued: string;
    /**
     * lock id
     * @type {string}
     * @memberof MailLogEntry
     */
    lock: string;
    /**
     * logger
     * @type {string}
     * @memberof MailLogEntry
     */
    logger: string;
    /**
     * mx port number
     * @type {number}
     * @memberof MailLogEntry
     */
    mxPort: number;
    /**
     * connection key
     * @type {string}
     * @memberof MailLogEntry
     */
    connectionKey: string;
    /**
     * mx hostname
     * @type {string}
     * @memberof MailLogEntry
     */
    mxHostname: string;
    /**
     * body hash
     * @type {string}
     * @memberof MailLogEntry
     */
    sentBodyHash: string;
    /**
     * sent body size in bytes
     * @type {number}
     * @memberof MailLogEntry
     */
    sentBodySize: number;
    /**
     * md5 checksum matching result
     * @type {number}
     * @memberof MailLogEntry
     */
    md5Match: number;
}
/**
 * Details for an Email
 * @export
 * @interface SendMail
 */
export interface SendMail {
    /**
     * The Contact whom is the primary recipient of this email.
     * @type {string}
     * @memberof SendMail
     */
    to: string;
    /**
     * The contact whom is the this email is from.
     * @type {string}
     * @memberof SendMail
     */
    from: string;
    /**
     * The subject or title of the email
     * @type {string}
     * @memberof SendMail
     */
    subject: string;
    /**
     * The main email contents.
     * @type {string}
     * @memberof SendMail
     */
    body: string;
}
/**
 * Details for an Email
 * @export
 * @interface SendMailAdv
 */
export interface SendMailAdv {
    /**
     * The subject or title of the email
     * @type {string}
     * @memberof SendMailAdv
     */
    subject: string;
    /**
     * The main email contents.
     * @type {string}
     * @memberof SendMailAdv
     */
    body: string;
    /**
     * 
     * @type {SendMailAdvFrom}
     * @memberof SendMailAdv
     */
    from: SendMailAdvFrom;
    /**
     * A list of destionation email addresses to send this to
     * @type {Array<SendMailAdvTo>}
     * @memberof SendMailAdv
     */
    to: Array<SendMailAdvTo>;
    /**
     * (optional) A list of email addresses that specify where replies to the email should be sent instead of the _from_ address.
     * @type {Array<SendMailAdvReplyto>}
     * @memberof SendMailAdv
     */
    replyto?: Array<SendMailAdvReplyto>;
    /**
     * (optional) A list of email addresses to carbon copy this message to.  They are listed on the email and anyone getting the email can see this full list of Contacts who received the email as well.
     * @type {Array<SendMailAdvCc>}
     * @memberof SendMailAdv
     */
    cc?: Array<SendMailAdvCc>;
    /**
     * (optional) list of email addresses that should receive copies of the email.  They are hidden on the email and anyone gettitng the email would not see the other people getting the email in this list.
     * @type {Array<SendMailAdvBcc>}
     * @memberof SendMailAdv
     */
    bcc?: Array<SendMailAdvBcc>;
    /**
     * (optional) File attachments to include in the email.  The file contents must be base64 encoded!
     * @type {Array<SendMailAdvAttachments>}
     * @memberof SendMailAdv
     */
    attachments?: Array<SendMailAdvAttachments>;
    /**
     * (optional)  ID of the Mail order within our system to use as the Mail Account.
     * @type {number}
     * @memberof SendMailAdv
     */
    id?: number;
}
/**
 * A File attachment for an email
 * @export
 * @interface SendMailAdvAttachments
 */
export interface SendMailAdvAttachments {
    /**
     * (optional) Filename to specify for the attachment.
     * @type {string}
     * @memberof SendMailAdvAttachments
     */
    filename?: string;
    /**
     * Contents of the attached file (must be base64 encoded)
     * @type {Blob}
     * @memberof SendMailAdvAttachments
     */
    data: Blob;
}
/**
 * An Email Contact
 * @export
 * @interface SendMailAdvBcc
 */
export interface SendMailAdvBcc {
    /**
     * The email address
     * @type {string}
     * @memberof SendMailAdvBcc
     */
    email: string;
    /**
     * (optional) Name to use for the BCC contact.
     * @type {string}
     * @memberof SendMailAdvBcc
     */
    name?: string;
}
/**
 * An Email Contact
 * @export
 * @interface SendMailAdvCc
 */
export interface SendMailAdvCc {
    /**
     * The email address
     * @type {string}
     * @memberof SendMailAdvCc
     */
    email: string;
    /**
     * (optional) Name to use for the CC contact.
     * @type {string}
     * @memberof SendMailAdvCc
     */
    name?: string;
}
/**
 * The information to use for the From address in the email. from.
 * @export
 * @interface SendMailAdvFrom
 */
export interface SendMailAdvFrom {
    /**
     * The email address
     * @type {string}
     * @memberof SendMailAdvFrom
     */
    email: string;
    /**
     * (optional) Name to use for the sending contact.
     * @type {string}
     * @memberof SendMailAdvFrom
     */
    name?: string;
}
/**
 * An Email Contact
 * @export
 * @interface SendMailAdvReplyto
 */
export interface SendMailAdvReplyto {
    /**
     * The email address
     * @type {string}
     * @memberof SendMailAdvReplyto
     */
    email: string;
    /**
     * (optional) Name to use for the sending contact.
     * @type {string}
     * @memberof SendMailAdvReplyto
     */
    name?: string;
}
/**
 * An Email Contact
 * @export
 * @interface SendMailAdvTo
 */
export interface SendMailAdvTo {
    /**
     * The email address
     * @type {string}
     * @memberof SendMailAdvTo
     */
    email: string;
    /**
     * (optional) Name to use for the destination contact.
     * @type {string}
     * @memberof SendMailAdvTo
     */
    name?: string;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary displays a list of mail service orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailOrders(options: any = {}): FetchArgs {
            const localVarPath = `/mail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the server is running
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options: any = {}): FetchArgs {
            const localVarPath = `/ping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.
         * @summary Sends an Email with Advanced Options
         * @param {SendMailAdv} body 
         * @param {string} subject 
         * @param {string} body 
         * @param {SendMailAdvFrom} from 
         * @param {Array<SendMailAdvTo>} to 
         * @param {Array<SendMailAdvReplyto>} replyto 
         * @param {Array<SendMailAdvCc>} cc 
         * @param {Array<SendMailAdvBcc>} bcc 
         * @param {Array<SendMailAdvAttachments>} attachments 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAdvMail(body: SendMailAdv, subject: string, body: string, from: SendMailAdvFrom, to: Array<SendMailAdvTo>, replyto: Array<SendMailAdvReplyto>, cc: Array<SendMailAdvCc>, bcc: Array<SendMailAdvBcc>, attachments: Array<SendMailAdvAttachments>, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'subject' is not null or undefined
            if (subject === null || subject === undefined) {
                throw new RequiredError('subject','Required parameter subject was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'replyto' is not null or undefined
            if (replyto === null || replyto === undefined) {
                throw new RequiredError('replyto','Required parameter replyto was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'cc' is not null or undefined
            if (cc === null || cc === undefined) {
                throw new RequiredError('cc','Required parameter cc was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'bcc' is not null or undefined
            if (bcc === null || bcc === undefined) {
                throw new RequiredError('bcc','Required parameter bcc was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'attachments' is not null or undefined
            if (attachments === null || attachments === undefined) {
                throw new RequiredError('attachments','Required parameter attachments was null or undefined when calling sendAdvMail.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendAdvMail.');
            }
            const localVarPath = `/mail/advsend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (subject !== undefined) {
                localVarFormParams.set('subject', subject as any);
            }

            if (body !== undefined) {
                localVarFormParams.set('body', body as any);
            }

            if (from !== undefined) {
                localVarFormParams.set('from', from as any);
            }

            if (to) {
                to.forEach((element) => {
                    localVarFormParams.append('to', element as any);
                })
            }

            if (replyto) {
                replyto.forEach((element) => {
                    localVarFormParams.append('replyto', element as any);
                })
            }

            if (cc) {
                cc.forEach((element) => {
                    localVarFormParams.append('cc', element as any);
                })
            }

            if (bcc) {
                bcc.forEach((element) => {
                    localVarFormParams.append('bcc', element as any);
                })
            }

            if (attachments) {
                attachments.forEach((element) => {
                    localVarFormParams.append('attachments', element as any);
                })
            }

            if (id !== undefined) {
                localVarFormParams.set('id', id as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"SendMailAdv" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
         * @summary Sends an Email
         * @param {string} to 
         * @param {string} from 
         * @param {string} subject 
         * @param {string} body 
         * @param {SendMail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail(to: string, from: string, subject: string, body: string, body: SendMail, options: any = {}): FetchArgs {
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling sendMail.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling sendMail.');
            }
            // verify required parameter 'subject' is not null or undefined
            if (subject === null || subject === undefined) {
                throw new RequiredError('subject','Required parameter subject was null or undefined when calling sendMail.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendMail.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendMail.');
            }
            const localVarPath = `/mail/send`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (to !== undefined) {
                localVarFormParams.set('to', to as any);
            }

            if (from !== undefined) {
                localVarFormParams.set('from', from as any);
            }

            if (subject !== undefined) {
                localVarFormParams.set('subject', subject as any);
            }

            if (body !== undefined) {
                localVarFormParams.set('body', body as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"SendMail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By passing in the appropriate options, you can search for available inventory in the system 
         * @summary displays the mail log
         * @param {number} [id] The ID of your mail order this will be sent through.
         * @param {string} [search] pass an optional search string for looking up inventory
         * @param {number} [skip] number of records to skip for pagination
         * @param {number} [limit] maximum number of records to return
         * @param {number} [startDate] earliest date to get emails in unix timestamp format
         * @param {number} [endDate] earliest date to get emails in unix timestamp format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewMailLog(id?: number, search?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, options: any = {}): FetchArgs {
            const localVarPath = `/mail/log`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary displays a list of mail service orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailOrders(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getMailOrders(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Checks if the server is running
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).pingServer(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.
         * @summary Sends an Email with Advanced Options
         * @param {SendMailAdv} body 
         * @param {string} subject 
         * @param {string} body 
         * @param {SendMailAdvFrom} from 
         * @param {Array<SendMailAdvTo>} to 
         * @param {Array<SendMailAdvReplyto>} replyto 
         * @param {Array<SendMailAdvCc>} cc 
         * @param {Array<SendMailAdvBcc>} bcc 
         * @param {Array<SendMailAdvAttachments>} attachments 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAdvMail(body: SendMailAdv, subject: string, body: string, from: SendMailAdvFrom, to: Array<SendMailAdvTo>, replyto: Array<SendMailAdvReplyto>, cc: Array<SendMailAdvCc>, bcc: Array<SendMailAdvBcc>, attachments: Array<SendMailAdvAttachments>, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).sendAdvMail(body, subject, body, from, to, replyto, cc, bcc, attachments, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
         * @summary Sends an Email
         * @param {string} to 
         * @param {string} from 
         * @param {string} subject 
         * @param {string} body 
         * @param {SendMail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail(to: string, from: string, subject: string, body: string, body: SendMail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).sendMail(to, from, subject, body, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * By passing in the appropriate options, you can search for available inventory in the system 
         * @summary displays the mail log
         * @param {number} [id] The ID of your mail order this will be sent through.
         * @param {string} [search] pass an optional search string for looking up inventory
         * @param {number} [skip] number of records to skip for pagination
         * @param {number} [limit] maximum number of records to return
         * @param {number} [startDate] earliest date to get emails in unix timestamp format
         * @param {number} [endDate] earliest date to get emails in unix timestamp format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewMailLog(id?: number, search?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MailLog> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).viewMailLog(id, search, skip, limit, startDate, endDate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary displays a list of mail service orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailOrders(options?: any) {
            return DefaultApiFp(configuration).getMailOrders(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Checks if the server is running
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options?: any) {
            return DefaultApiFp(configuration).pingServer(options)(fetch, basePath);
        },
        /**
         * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.
         * @summary Sends an Email with Advanced Options
         * @param {SendMailAdv} body 
         * @param {string} subject 
         * @param {string} body 
         * @param {SendMailAdvFrom} from 
         * @param {Array<SendMailAdvTo>} to 
         * @param {Array<SendMailAdvReplyto>} replyto 
         * @param {Array<SendMailAdvCc>} cc 
         * @param {Array<SendMailAdvBcc>} bcc 
         * @param {Array<SendMailAdvAttachments>} attachments 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAdvMail(body: SendMailAdv, subject: string, body: string, from: SendMailAdvFrom, to: Array<SendMailAdvTo>, replyto: Array<SendMailAdvReplyto>, cc: Array<SendMailAdvCc>, bcc: Array<SendMailAdvBcc>, attachments: Array<SendMailAdvAttachments>, id: number, options?: any) {
            return DefaultApiFp(configuration).sendAdvMail(body, subject, body, from, to, replyto, cc, bcc, attachments, id, options)(fetch, basePath);
        },
        /**
         * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
         * @summary Sends an Email
         * @param {string} to 
         * @param {string} from 
         * @param {string} subject 
         * @param {string} body 
         * @param {SendMail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail(to: string, from: string, subject: string, body: string, body: SendMail, options?: any) {
            return DefaultApiFp(configuration).sendMail(to, from, subject, body, body, options)(fetch, basePath);
        },
        /**
         * By passing in the appropriate options, you can search for available inventory in the system 
         * @summary displays the mail log
         * @param {number} [id] The ID of your mail order this will be sent through.
         * @param {string} [search] pass an optional search string for looking up inventory
         * @param {number} [skip] number of records to skip for pagination
         * @param {number} [limit] maximum number of records to return
         * @param {number} [startDate] earliest date to get emails in unix timestamp format
         * @param {number} [endDate] earliest date to get emails in unix timestamp format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewMailLog(id?: number, search?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, options?: any) {
            return DefaultApiFp(configuration).viewMailLog(id, search, skip, limit, startDate, endDate, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary displays a list of mail service orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMailOrders(options?: any) {
        return DefaultApiFp(this.configuration).getMailOrders(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Checks if the server is running
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pingServer(options?: any) {
        return DefaultApiFp(this.configuration).pingServer(options)(this.fetch, this.basePath);
    }

    /**
     * Sends An email through one of your mail orders allowing additional options such as file attachments, cc, bcc, etc.
     * @summary Sends an Email with Advanced Options
     * @param {SendMailAdv} body 
     * @param {string} subject 
     * @param {string} body 
     * @param {SendMailAdvFrom} from 
     * @param {Array<SendMailAdvTo>} to 
     * @param {Array<SendMailAdvReplyto>} replyto 
     * @param {Array<SendMailAdvCc>} cc 
     * @param {Array<SendMailAdvBcc>} bcc 
     * @param {Array<SendMailAdvAttachments>} attachments 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sendAdvMail(body: SendMailAdv, subject: string, body: string, from: SendMailAdvFrom, to: Array<SendMailAdvTo>, replyto: Array<SendMailAdvReplyto>, cc: Array<SendMailAdvCc>, bcc: Array<SendMailAdvBcc>, attachments: Array<SendMailAdvAttachments>, id: number, options?: any) {
        return DefaultApiFp(this.configuration).sendAdvMail(body, subject, body, from, to, replyto, cc, bcc, attachments, id, options)(this.fetch, this.basePath);
    }

    /**
     * Sends an email through one of your mail orders.  *Note*: If you want to send to multiple recipients or use file attachments use the advsend (Advanced Send) call instead. 
     * @summary Sends an Email
     * @param {string} to 
     * @param {string} from 
     * @param {string} subject 
     * @param {string} body 
     * @param {SendMail} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sendMail(to: string, from: string, subject: string, body: string, body: SendMail, options?: any) {
        return DefaultApiFp(this.configuration).sendMail(to, from, subject, body, body, options)(this.fetch, this.basePath);
    }

    /**
     * By passing in the appropriate options, you can search for available inventory in the system 
     * @summary displays the mail log
     * @param {number} [id] The ID of your mail order this will be sent through.
     * @param {string} [search] pass an optional search string for looking up inventory
     * @param {number} [skip] number of records to skip for pagination
     * @param {number} [limit] maximum number of records to return
     * @param {number} [startDate] earliest date to get emails in unix timestamp format
     * @param {number} [endDate] earliest date to get emails in unix timestamp format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public viewMailLog(id?: number, search?: string, skip?: number, limit?: number, startDate?: number, endDate?: number, options?: any) {
        return DefaultApiFp(this.configuration).viewMailLog(id, search, skip, limit, startDate, endDate, options)(this.fetch, this.basePath);
    }

}
