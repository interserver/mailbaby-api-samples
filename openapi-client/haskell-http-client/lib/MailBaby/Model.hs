{-
   Mail Baby API

   This is an API for accesssing the mail services.

   OpenAPI Version: 3.0.0
   Mail Baby API API version: 1.0.0
   Contact: detain@interserver.net
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : MailBaby.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module MailBaby.Model where

import MailBaby.Core
import MailBaby.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Body
newtype Body = Body { unBody :: Text } deriving (P.Eq, P.Show)

-- ** From
newtype From = From { unFrom :: Text } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Integer } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** SearchString
newtype SearchString = SearchString { unSearchString :: Text } deriving (P.Eq, P.Show)

-- ** Skip
newtype Skip = Skip { unSkip :: Int } deriving (P.Eq, P.Show)

-- ** Subject
newtype Subject = Subject { unSubject :: Text } deriving (P.Eq, P.Show)

-- ** To
newtype To = To { unTo :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Error
-- | Error
data Error = Error
  { errorCode :: !(Text) -- ^ /Required/ "code"
  , errorMessage :: !(Text) -- ^ /Required/ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:  "code")
      <*> (o .:  "message")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "code" .= errorCode
      , "message" .= errorMessage
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Text -- ^ 'errorCode' 
  -> Text -- ^ 'errorMessage' 
  -> Error
mkError errorCode errorMessage =
  Error
  { errorCode
  , errorMessage
  }

-- ** GenericResponse
-- | GenericResponse
data GenericResponse = GenericResponse
  { genericResponseStatus :: !(Maybe Text) -- ^ "status"
  , genericResponseStatusText :: !(Maybe Text) -- ^ "status_text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenericResponse
instance A.FromJSON GenericResponse where
  parseJSON = A.withObject "GenericResponse" $ \o ->
    GenericResponse
      <$> (o .:? "status")
      <*> (o .:? "status_text")

-- | ToJSON GenericResponse
instance A.ToJSON GenericResponse where
  toJSON GenericResponse {..} =
   _omitNulls
      [ "status" .= genericResponseStatus
      , "status_text" .= genericResponseStatusText
      ]


-- | Construct a value of type 'GenericResponse' (by applying it's required fields, if any)
mkGenericResponse
  :: GenericResponse
mkGenericResponse =
  GenericResponse
  { genericResponseStatus = Nothing
  , genericResponseStatusText = Nothing
  }

-- ** MailLog
-- | MailLog
-- Mail Order Details
data MailLog = MailLog
  { mailLogId :: !(Maybe Integer) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MailLog
instance A.FromJSON MailLog where
  parseJSON = A.withObject "MailLog" $ \o ->
    MailLog
      <$> (o .:? "id")

-- | ToJSON MailLog
instance A.ToJSON MailLog where
  toJSON MailLog {..} =
   _omitNulls
      [ "id" .= mailLogId
      ]


-- | Construct a value of type 'MailLog' (by applying it's required fields, if any)
mkMailLog
  :: MailLog
mkMailLog =
  MailLog
  { mailLogId = Nothing
  }

-- ** MailOrder
-- | MailOrder
data MailOrder = MailOrder
  { mailOrderId :: !(Int) -- ^ /Required/ "id"
  , mailOrderStatus :: !(Text) -- ^ /Required/ "status"
  , mailOrderUsername :: !(Text) -- ^ /Required/ "username"
  , mailOrderPassword :: !(Maybe Text) -- ^ "password"
  , mailOrderComment :: !(Maybe Text) -- ^ "comment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MailOrder
instance A.FromJSON MailOrder where
  parseJSON = A.withObject "MailOrder" $ \o ->
    MailOrder
      <$> (o .:  "id")
      <*> (o .:  "status")
      <*> (o .:  "username")
      <*> (o .:? "password")
      <*> (o .:? "comment")

-- | ToJSON MailOrder
instance A.ToJSON MailOrder where
  toJSON MailOrder {..} =
   _omitNulls
      [ "id" .= mailOrderId
      , "status" .= mailOrderStatus
      , "username" .= mailOrderUsername
      , "password" .= mailOrderPassword
      , "comment" .= mailOrderComment
      ]


-- | Construct a value of type 'MailOrder' (by applying it's required fields, if any)
mkMailOrder
  :: Int -- ^ 'mailOrderId' 
  -> Text -- ^ 'mailOrderStatus' 
  -> Text -- ^ 'mailOrderUsername' 
  -> MailOrder
mkMailOrder mailOrderId mailOrderStatus mailOrderUsername =
  MailOrder
  { mailOrderId
  , mailOrderStatus
  , mailOrderUsername
  , mailOrderPassword = Nothing
  , mailOrderComment = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyApiKeyAuth
data AuthApiKeyApiKeyAuth =
  AuthApiKeyApiKeyAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKeyAuth where
  applyAuthMethod _ a@(AuthApiKeyApiKeyAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-API-KEY", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyApiLoginAuth
data AuthApiKeyApiLoginAuth =
  AuthApiKeyApiLoginAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiLoginAuth where
  applyAuthMethod _ a@(AuthApiKeyApiLoginAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-API-LOGIN", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyApiPasswordAuth
data AuthApiKeyApiPasswordAuth =
  AuthApiKeyApiPasswordAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiPasswordAuth where
  applyAuthMethod _ a@(AuthApiKeyApiPasswordAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-API-PASS", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


